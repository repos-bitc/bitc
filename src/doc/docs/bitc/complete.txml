<?xml version="1.0"?>
<!DOCTYPE article PUBLIC "-//EROS Group//DTD OSDoc XML V0.1//EN"
               "http://www.coyotos.org/OSDoc/DTD/osdoc-0.1.dtd" [
]>
  <article id="asplas" 
    xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:btypes="http://www.bitc-lang.org/DTD/bitc/0.1/bitc-types.dtd">
  <docinfo ptsz='default' latex.documentclass="llncs">
    <title>A Theory of Well-founded First Class Mutability</title>
    <authorgroup>
      <author>
      	<firstname>Swaroop</firstname>
      	<surname>Sridhar</surname>
      	<email>swaroop@cs.jhu.edu</email>
      </author>
      <author>
      	<firstname>Jonathan</firstname>
        <othername>S.</othername>
      	<surname>Shapiro</surname>
      	<email>shap@eros-os.org</email>
      </author>
      <author>
      	<firstname>Scott</firstname>
        <othername>F.</othername>
      	<surname>Smith</surname>
      	<email>scott@cs.jhu.edu</email>
      </author>
      <affiliation>
	<address>
	  <em>Department of Computer Science</em>,
	  The Johns Hopkins University</address> 
      	<email>
	  swaroop@cs.jhu.edu, shap@cs.jhu.edu, scott@cs.jhu.edu
	</email>
      	<!-- <orgname>Department of Computer Science</orgname>
	<address>The Johns Hopkins University</address> 
	<address>3400 N. Charles Street, 224 NEB, 
	  Baltimore, MD 21218</address>
      	<email>
	  swaroop@cs.jhu.edu, shap@cs.jhu.edu, scott@cs.jhu.edu
	</email> -->
      </affiliation>
    </authorgroup>
    <pubdate></pubdate>
    <!-- <categories>
    <category>dev/bitc</category>
  </categories> -->
    <synopsis>
      <p>
        A Theory of BitC mutability model and type inference.
      </p>
    </synopsis>
  </docinfo> 
  <abstract latex.incolumn="yes">
    <p>
      This paper introduces a new type system that is designed for
      safe systems programming. A key feature of the type system is
      a new mutability model that combines explicitly unboxed types
      with a consistent typing of mutability. The type system is
      provably sound, supports polymorphism and type inference,
      and eliminates the need for alias analysis to determine the
      immutability of a location. 
    </p>
  </abstract>
  <sect1>
    <title>Introduction</title>
    <p>
      Recent advances in the theory and practice of programming
      languages have resulted in modern languages and tools that
      provide certain correctness guarantees regarding the execution
      of programs. However, these advances have not been effectively
      applied to the construction of <em>systems programs</em>, the
      core components of a computer system. One of the primary causes
      of this problem is the fact that existing languages do not
      simultaneously support modern language features (such as static
      type safety, type inference, higher order functions and
      polymorphism) and features
      that are critical to the correctness and performance of systems
      programs (such as prescriptive data structure representation and
      mutability). In this paper, we endeavour to bride this gap
      between modern language design and systems programming. We
      first discuss the support for these features in existing
      languages, identify the challenges in combining these feature
      sets and then describe our approach toward solving this problem. 
    </p>
    <p>
      <leadin>Representation Control:</leadin> A systems programming
      language must be expressive enough to specify details of
      data-structure layout (boxed or unboxed), alignment and
      allocation (stack or heap). This feature is essential for
      systems programming for reasons of performance (ex: to control
      cache and paging behavior), conformance to hardware
      specification (ex: page table entries), and interfacing with
      external C or assembly  code and data. A careful
      implementation of the standard TCP/IP protocol stack in Standard
      ML incurs a substantial overhead of up to 10x increase in system
      load and a 40x slowdown in accessing external memory relative to
      the equivalent C implementation&nbsp;<cites> 
	<cite ref="Biagioni2001FoxNet"/>
	<cite ref="Derby1999Foxnet"/>
      </cites>.  This shows that in systems programs, data structure
      representation is as important as, or even more important than
      high level algorithms.
    </p>
    <p>
      The philosophy of ML-like languages is that programs specify
      semantics and not realization (implementation). Omitting the
      details of representation and allocation from the language
      definition greatly simplifies mathematical description of the
      language. However, in systems programs, statements about
      representation and location are <em>prescriptive</em>, not
      <em>descriptive</em>. Compilers like TIL&nbsp;<cite
	ref="Tarditi1996TIL"/> implement unboxed representation as a
      discretionary optimization. Prescriptive requirements are not
      discretionary. Formal treatment of representation is required in
      systems programming languages.
    </p>
    <p>
      <leadin>Mutability Support:</leadin> One of the key features
      essential for systems programming is support for mutability. The
      support for mutability must be complete in the sense that any
      location (stack or heap, boxed or unboxed) can be mutable. From
      a performance standpoint, mutability of stack locations is very
      desirable because the stack is typically cache hot, and stack
      allocations do not involve garbage collection overhead.
      Mutability of stack locations is a requirement in the case of
      high-assurance kernels which cannot afford dynamic memory
      allocation beyond initialization. Modern languages like ML
      provide limited support for mutability &mdash; all mutable
      (<progident>ref</progident>) cells must reside in the heap.
      While this restricted mutability model simplifies the
      formalism by maintaining a clear separation of immutable
      bindings and mutable references, it is insufficiently expressive
      from a systems programming perspective.
      Haskell is a pure functional language in which mutable state must be
      encapsulated within Monads&nbsp;<cite ref="peytonjones1993monads"/>. 
    </p>
    <p>
      <leadin>Type Inference and Polymorphism:</leadin> Type
      inference achieves the advantages of static typing
      with a lower burden on the programmer, facilitating rapid
      prototyping and development. Polymorphic type inference 
      (c.f. ML&nbsp;<cite ref="milner97definition"/> or 
      Haskell&nbsp;<cite ref="peytonjones2003haskellrevisedreport"/>)
      combines the advantages of static type safety with much of the
      convenience provided by dynamically typed languages like
      Python&nbsp;<cite ref="pythonSpec"/>. 
      Automatic inference of polymorphism simplifies generic programming, and
	therefore increases the reuse and reliability of code.
      Safe languages like Java&nbsp;<cite ref="javaSpec"/>, 
      C#&nbsp;<cite ref="csharpSpec"/>, 
      or Vault&nbsp;<cite ref="DeLineMSRVault"/> do not support type
      inference. Cyclone&nbsp;<cite ref="Jim2002Cyclone"/> features
      partial type inference and supports polymorphism only for
      functions that are explicitly annotated with a polymorphic type.
    </p>
    <p>
      The following table summarizes the support available in 
      existing languages for the above features and static
      type safety:
    </p>
    <xi:include href="include/complete/lang-comp.xmli"/>
    <p>
      <br/>
      <br/>
      While several of the existing safe
      languages support two of the three features  &mdash; unboxed
      representation, mutability and polymorphic type inference
      &mdash; none combine all of them elegantly. Therefore,
      systems programmers either continue to use languages such as
      Ada&nbsp;<cite ref="ISO1995Ada"/>, 
      C&nbsp;<cite ref="ISO1999ANSI-C"/>, 
      C++&nbsp;<cite ref="ISO1998C++"/>,
      <foreignphrase>etc.</foreignphrase>, or follow a ``two
      language'' discipline where the system is implemented using a
      combination of safe and unsafe languages. For example, the
      SwitchWare&nbsp;<cite ref="Alexander98"/>
      active network architecture is largely implemented in
      Ocaml&nbsp;<cite ref="LeroyOcaml"/>, but uses
      C implementations of certain high performance
      components such as SHA-1 hash function.
    </p>
    <p>
      The presence of unboxed data structures and mutability presents
      several challenges for type inference. Mutability is an
      attribute of the <em>location</em> storing a value and not the
      value itself. Therefore, two expressions across a copy boundary
      (ex: formal vs actual arguments of a function) can
      differ in their mutability. This creates a situation where type
      and mutability inference is not purely syntax directed. Type
      inference is further complicated due to well known problems with
      the interaction of mutability and polymorphism&nbsp;<cite
	ref="wrightValRes1995"/>. This has
      forced a second-class treatment of mutability in ML-like
      languages and a lack of inferred polymorphism in others.
    </p>
    <p>
      In this paper, we present a new type system and formal
      foundations for a safe systems programming language that
      supports all of the desirable features mentioned above.
      The type system features a new model of mutability which is
      expressive and has sound semantics. In order to support unboxed
      mutability and principal polymorphic type inference, the type
      system uses types that are range over mutability
      and polymorphism itself. We also present a sound and complete
      type inference system through an extension of the
      Hindley-Milner algorithm&nbsp;<cite ref="Milner1978W"/>. 
      Safety of the type system as well as soundness and completeness
      of the inference algorithm have been proved.
    </p>
  </sect1>
  <sect1 id="language">
    <title>The Language</title>
    <p>
      For purposes of presentation in this paper, we define
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, a core systems programming language calculus. 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> is a direct expression of lambda
      calculus with side effects, extended to be able to reflect the
      semantics of explicit representation. 
    </p>
    <xi:include href="include/complete/lang.xmli"/>
    <p>
      The type
      <btypes:TYPE>
	<ref>
	  <type/>
	</ref>
      </btypes:TYPE> represents a reference (pointer) type and 
      <btypes:TYPE>
	<mutable>
	  <ptype/>
	</mutable>
      </btypes:TYPE> represents a mutable type. 
      The expression
      <btypes:TYPE>
	<dup>
	  <aExpr/>
	</dup>
      </btypes:TYPE>,
      where 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>
      has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>,
      returns a reference 
      of type
      <btypes:TYPE>
	<ref>
	  <type/>
	</ref>
      </btypes:TYPE> to a heap-allocated <em>copy</em>
      of the value of 
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>. 
      The <progident>^</progident> operator is used to
      dereference heap cells.       
      Pairs <progident>(,)</progident>
      are <em>unboxed</em> structures whose
      constituent elements are contiguously allocated on the
      stack, or in their containing data-structure. 
      <btypes:TYPE>
	<fst>
	  <aExpr/>
	</fst>
	<text content=" and "/>
	<snd>
	  <aExpr/>
	</snd>
      </btypes:TYPE> perform selection from pairs.
      We define
      <btypes:TYPE>
	<eq>
	  <other>
	    <texttt content="1"/>
	  </other>
	  <texttt content="2"/>
	</eq>
      </btypes:TYPE> and
      <btypes:TYPE>
	<eq>
	  <other>
	    <texttt content="2"/>
	  </other>
	  <texttt content="1"/>
	  </eq>
      </btypes:TYPE>.
    </p>
    <p>
      The <progident>let</progident> construct can be used for
      allocating (possibly mutable) stack variables and to create
      let-polymorphic bindings.
      <progident>let</progident>&nbsp;<btypes:TYPE>
	<tqExpr optional="yes">
	  <id/>
	  <type/>
	</tqExpr>
      </btypes:TYPE> represents optional type qualification of
      let-bound variables. The <progident>:=</progident> operator
      mutates both stack locations (let-bound locals, function
      parameters) and heap locations (<progident>dup</progident>-ed
      values). Unlike ML, <progident>:=</progident> does not
      dereference its target.  
    </p>
    <p>
      <font color="purple">
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> does
      not include an address <progident>&amp;</progident> operator to
      obtain the address of stack locations. First, the safety
      of <progident>&amp;</progident> operator is an orthogonal
      problem that has been studied in the literature&nbsp;<cite
	ref="Grossman2006qtypes"/> and can be incorporated
      into the language if necessary.
      Second, it is unclear whether the <progident>&amp;</progident>
      operator is necessary in a safe systems programming language.
      There are examples of high performance security kernels
      that have been constructed without taking the address of stack
      variables, even though they rely on stack allocation and
      mutation for correctness and 
      performance&nbsp;<cite ref="shapiro1999EROS"/>. 
      </font>
    </p>
  </sect1>
  <sect1 id="mut_model">
    <title>The Mutability Model</title>
    <p>
      Traditionally, there are two models of mutability studied in the
      case of imperative languages. One of them is the ML model, where
      there is a clear separation between name bindings and updatable
      locations. All updatable (mutable) locations live in the heap
      within ``ref cells''. Fetching the value inside a ref cell
      requires an explicit dereferencing operation. The major
      advantage of this approach is that types are definitive about the
      mutability of every location, across all aliases. In this sense,
      we can say that the support for mutability is mathematically
      ``well-founded.'' This model benefits tools
      that perform static analysis or model checking because
      conclusions drawn about location immutability need never be
      conservative. This model of mutability also increases the amount
      of optimization the compiler can safely perform without complex
      alias analysis.
    </p>
    <p>
      The other well known model of mutability is the C model, wherein
      the support for mutability is ``first-class'' in the sense that
      <em>all</em> locations can be mutable. This model permits mutation of
      stack variables and unboxed values. There is a notion of
      <em>left</em> expressions which can be the target of an
      assignment, and <em>right</em> expressions represent all other
      computations. The extraction of the value from a (mutable) 
      location is implicit, and does not require dereferencing.
      However, in this model, types cannot distinguish mutable values
      from immutable ones. For example, in C it is legal to write: 
      <br/>
      <progident>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	const bool *cp = ...;   
	bool *p = cp;
	*p = false;  // OK!
      </progident>
    </p>
    <p>
      The alleged ``constness'' of the location pointed to by
      <progident>cp</progident> is a local property (only) with
      respect to the alias <progident>cp</progident> and not a
      statement of true immutability of the target location. 
      The compiler or other analytical engines are not entitled to
      believe that certain locations or fields are constant even if so
      declared.
    </p>
    <p>
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>
      supports well-founded first class mutability. Similar to
      ML, we impose the ``one location, one type'' rule.
      <br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <btypes:TYPE>
	<let>
	  <tqExpr>
	    <id name="cp"/>
	    <ref>
	      <bool/>
	    </ref>
	  </tqExpr>
	  <dup>
	    <true/>
	  </dup>
	  <let>
	    <tqExpr>
	      <id name="p"/>
	      <ref>
		<mutable>
		  <bool/>
		</mutable>
	      </ref>
	    </tqExpr>
	    <id name="cp"/>
	  </let>
	</let>
      </btypes:TYPE>
      &nbsp;&nbsp;
      <progident>
	(* Error *)
      </progident>
      <br/>
      We see that
      <btypes:TYPE>
	<id name="cp"/>
      </btypes:TYPE> has the type reference to bool
      (<btypes:TYPE>
	<ref>
	  <bool/>
	</ref>
      </btypes:TYPE>). This type is incompatible with that of 
       <btypes:TYPE>
	<id name="p"/>
      </btypes:TYPE>, reference to mutable-bool
      (<btypes:TYPE>
	<ref>
	  <mutable>
	    <bool/>
	  </mutable>
	</ref>
      </btypes:TYPE>).
      Similar to the C model, a notion of left expressions (defined in
      Section&nbsp;<xref ref="language"/>) is necessary to preserve
      the programmer's mental model of the relationship between
      locations storage and to ensure that compiler transformations
      are semantics preserving.
    </p>
  </sect1>
  <sect1 id="copy_compat">
    <title>Copy Compatibility</title> 
    <p>
      Since <btypes:TYPE> <language/> </btypes:TYPE> is a
      call-by-value language, it is desirable that we allow some
      freedom in the compatibility of types with respect to their
      mutability at a copy boundary. For example, in the
      following expression: 
      <br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <btypes:TYPE>
	<let>
	  <id name="fnxn"/>
	  <lambda>
	    <id name="x"/>
	    <paren>
	      <assign>
		<id name="x"/>
		<false/>
	      </assign>
	    </paren>
	  </lambda>
	  <let>	    
	    <tqExpr>
	      <id name="y"/>
	      <bool/>
	    </tqExpr>
	    <true/>
	    <apply>
	      <id name="fnxn"/>
	      <id name="y"/>
	    </apply>
	  </let>
	</let>
      </btypes:TYPE>
      <br/>
      the type of
      <btypes:TYPE>
	<id name="fnxn"/>
      </btypes:TYPE> is
      <btypes:TYPE>
	<fn>
	  <paren>
	    <mutable>
	      <bool/>
	    </mutable>
	  </paren>
	  <unit/>
	</fn>
      </btypes:TYPE>, whereas that of the actual argument
      <btypes:TYPE>
	<id name="y"/>
      </btypes:TYPE> is
      <btypes:TYPE>
	<bool/>
      </btypes:TYPE>.
      Since the formal argument
      <btypes:TYPE>
	<id name="x"/>
      </btypes:TYPE> is a <em>copy</em> of 
      <btypes:TYPE>
	<id name="y"/>
      </btypes:TYPE> and occupies a different location, 
      this expression is type safe. We refer to this notion
      of compatibility of types as <term>copy compatibility</term>.
      denoted by &cong;. In this example,
      <btypes:TYPE>
	<ceq>
	  <bool/>
	  <mutable>
	    <bool/>
	  </mutable>
	</ceq>
      </btypes:TYPE>.
    </p>
    <p>
      Copy compatibility need not be restricted to the outermost
      mutability compatibility      
      (<btypes:TYPE>
	<TceqOp/>
      </btypes:TYPE>), but must not extend past a reference
      boundary in order ensure that every location has unique type.
      We define copy compatibility for 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> as:
    </p>    
    <font size="small">
      <btypes:TYPE>
	<Hrules initsep="20" colsep="3">
	  <tyRule>
	    <tyPre/>
	    <tyConc>
	      <Tceq>                
		<type/>
		<type/>
	      </Tceq>
	    </tyConc>                
	  </tyRule>
	  <tyRule>
	    <tyPre>
	      <Tceq>
		<type num="1"/>
		<type num="2"/>
	      </Tceq>
	    </tyPre>
	    <tyConc>
	      <Tceq>
		<type num="2"/>
		<type num="1"/>
	      </Tceq>
	    </tyConc>
	  </tyRule>
	  <tyRule>
	    <tyPre>
	      <Tceq>                
		<type num="1"/>
		<type num="2"/>
	      </Tceq>
	      <Tceq>                
		<type num="2"/>
		<type num="3"/>
	      </Tceq>	    
	    </tyPre>
	    <tyConc>
	      <Tceq>
		<type num="1"/>
		<type num="3"/>
	      </Tceq>
	    </tyConc>                
	  </tyRule>
	  <tyRule>
	    <tyPre/>
	    <tyConc>
	      <Tceq>                
		<mutable>
		  <ptype/>
		</mutable>
		<ptype/>
	      </Tceq>
	    </tyConc>
	  </tyRule>
	</Hrules>
	<Hrules initsep="2" colsep="3">
	  <tyRule>
	    <tyPre/>
	    <tyConc>
	      <ceq>                
		<type/>
		<type/>
	      </ceq>
	    </tyConc>                
	  </tyRule>   
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type num="1"/>
		<type num="2"/>
	      </ceq>	    
	    </tyPre>
	    <tyConc>
	      <ceq>
		<type num="2"/>
		<type num="1"/>
	      </ceq>
	    </tyConc>                
	  </tyRule>
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type num="1"/>
		<type num="2"/>
	      </ceq>
	      <ceq>                
		<type num="2"/>
		<type num="3"/>
	      </ceq>	    
	    </tyPre>
	    <tyConc>
	      <ceq>
		<type num="1"/>
		<type num="3"/>
	      </ceq>
	    </tyConc>                
	  </tyRule>
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type/>
		<ptype/>
	      </ceq>	    
	    </tyPre>
	    <tyConc>
	      <ceq>                
		<type/>
		<mutable>
		  <ptype/>
		</mutable>
	      </ceq>
	    </tyConc>                
	  </tyRule>   
	  <tyRule>
	    <tyPre>
	      <ceq>                
		<type num="1"/>
		<type num="1" dash="'"/>
	      </ceq>
	      <ceq>
		<type num="2"/>
		<type num="2" dash="'"/>
	      </ceq>
	    </tyPre>
	    <tyConc>
	      <ceq>
		<pair>
		  <type num="1"/>
		  <type num="2"/>
		</pair>
		<pair>
		  <type num="1" dash="'"/>
		  <type num="2" dash="'"/>
		</pair>
	      </ceq>
	    </tyConc>                
	  </tyRule>
	</Hrules>
      </btypes:TYPE>
    </font>
    <br/>
    <p>
      Copy compatibility can be permitted at argument passing, new
      variable binding, assignment, and basically at argument/return
      positions of all expressions, except where a left expression is
      expected or returned. For example, the expression
      <btypes:TYPE>
	<tqExpr>
	  <paren>
	    <tqExpr>
	      <id name="x"/>
	      <type/>
	    </tqExpr>
	  </paren>
	  <mutable>
	    <type/>
	  </mutable>
	</tqExpr>
      </btypes:TYPE> is ill typed, but 
      the branches of a conditional can have
      different but copy compatible types as in:
      <btypes:TYPE>
	<if>
	  <true/>
	  <tqExpr>
	    <id name="a"/>
	    <type/>
	  </tqExpr>
	  <tqExpr>
	    <id name="b"/>
	    <mutable>
	      <type/>
	    </mutable>
	  </tqExpr>
	</if>
      </btypes:TYPE>.
    </p>
  </sect1>
  <sect1 id="infer">
    <title>Type Inference</title>
    <p>
      We now consider the problem of designing a type inference
      algorithm for 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>.
      Due to copy compatibility, it is no longer possible
      to infer a unique (simple) type for all expressions. 
      For example, in the expression
      <btypes:TYPE>
	<let>
	  <id name="p"/>
	  <true/>
	</let>
      </btypes:TYPE>, 
      we know that the type of the literal
      <btypes:TYPE>
	<true/>
      </btypes:TYPE> is
      <btypes:TYPE>
	<bool/>
      </btypes:TYPE>, but the type of
      <btypes:TYPE>
	<id name="p"/>
      </btypes:TYPE>
      could either be
      <btypes:TYPE>
	<bool/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<mutable>
	  <bool/>
	</mutable>
      </btypes:TYPE>. Therefore, unlike ML, type inference is not
      purely syntax directed in 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>.
    </p>
    <p>
      It is natural to ask why mutability should be inferred at all.
      That is: why not require explicit annotation for all mutable
      values, and infer immutable types by default? In a language with
      copy compatibility, this will result in a proliferation of type 
      annotations. Constructor applications, 
      polymorphic type instantiations, accessor functions,
      <foreignphrase>etc.</foreignphrase> 
      will have to be explicitly annotated with their types. For
      example, if
      <btypes:TYPE> 
	<id name="fst"/>
      </btypes:TYPE>
      is an accessor function that returns the first element of a
      pair, and  
      <btypes:TYPE> 
	<id name="m"/>
      </btypes:TYPE>
      is a variable of type
      <btypes:TYPE> 
	<mutable>
	  <bool/>
	</mutable>
      </btypes:TYPE>, we will have to write: 
      <br/>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <btypes:TYPE> 
	<let>
	  <id name="xyz"/>
	  <tqExpr>
	    <dup>
	      <apply>
		<id name="fst"/>
		<tqExpr nosp="yes">
		  <Pair>
		    <id name="m"/>
		    <false/>
		  </Pair>
		  <pair>
		    <mutable>
		      <bool/>
		    </mutable>
		    <bool/>
		  </pair>
		</tqExpr>
	      </apply>
	    </dup>
	    <ref>
	      <mutable>
		<bool/>
	      </mutable>
	    </ref>
	  </tqExpr>
	  <unspecified/>
	</let>
      </btypes:TYPE>
      <br/>
      Therefore, if mutability is not inferred, it results in a
      substantial increase in the number of programmer annotations,
      and type inference becomes ineffective.
      It is desirable that the inference algorithm must
      automatically infer polymorphism (without any programmer
      annotations) as well, since this leads to better software
      engineering by maximizing code reuse.
    </p>
    <p>
      Therefore, the desirable characteristics of a type inference
      algorithm for   
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> are:
    </p>
    <ol>
      <li>
	<p>
	  It must be sound, complete, and decidable without programmer
	  annotations. 
	</p>
      </li>
      <li>
	<p>
	  It must automatically infer both polymorphism and
	  mutability.
	</p>
      </li>
      <li>
	<p>
	  It must infer types that are intelligible to the programmer.
	  That is, it must avoid the main drawback of many inference
	  systems with subtyping, where the inferred principal type is
	  presented a set of equations and inequations.
	</p>
      </li>
    </ol>
    <p>
      In order to address the above requirements, we propose a
      variant of the Hindley-Milner algorithm&nbsp;<cite
	ref="Milner1978W"/>. This algorithm uses polymorphism over
      mutability and polymorphism itself in order to infer principal
      types for       
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> programs.
    </p>
    <p>
      <leadin>Polymorphism Over Mutability</leadin>
      In order to infer principal types in a language with copy
      compatibility, we define the following constrained types that
      allow us to infer types with variable mutability:
      <br/>
      <btypes:TYPE>
	<equiv>
	  <mbTop>
	    <tvar/>
	    <ptype/>
	  </mbTop>
	  <ctype>
	    <tvar/>
	    <set>
	      <Tceq>
		<tvar/>
		<ptype/>
	      </Tceq>
	    </set>
	  </ctype>
	</equiv>
      </btypes:TYPE>:
      any type equal to base type 
      <btypes:TYPE>
	<ptype/>
      </btypes:TYPE> except for top level mutability.
      <br/>
      <btypes:TYPE>
	<equiv>
	  <mbFull>
	    <stype/>
	    <ptype/>
	  </mbFull>
	  <ctype>
	    <stype/>
	    <set>
	      <ceq>
		<stype/>
		<ptype/>
	      </ceq>
	    </set>
	  </ctype>
	</equiv>
      </btypes:TYPE>:
      any type copy compatible with
      <btypes:TYPE>
	<ptype/>
      </btypes:TYPE>, where
      <btypes:TYPE>
	<eq>
	  <stype/>
	  <grouping>
	    <tvar/>
	    <text content=" or "/>
	    <mutable>
	      <tvar/>
	    </mutable>
	  </grouping>
	</eq>
      </btypes:TYPE>.
    </p>
    <p>
      Now, in the expression
      <btypes:TYPE>
	<let>
	  <id name="p"/>
	  <true/>
	</let>
      </btypes:TYPE>, 
      we can give
      <btypes:TYPE>
	<id name="p"/>
      </btypes:TYPE>  the type
      <btypes:TYPE>
	<mbFull>
	  <tvar/> 	  
	  <bool/>
	</mbFull>
      </btypes:TYPE>.
      During inference, the type can later get resolved to either
      <btypes:TYPE>
	<bool/>
      </btypes:TYPE> or
      <btypes:TYPE>
	<mutable>
	  <bool/>
	</mutable>
      </btypes:TYPE>.
      The forms 
      <btypes:TYPE>
	<mbTop>
	  <tvar/>
	  <ptype/>
	</mbTop>
      </btypes:TYPE> and
      <btypes:TYPE>
	<mbFull>
	  <stype/>
	  <ptype/>
	</mbFull>
      </btypes:TYPE> respectively provide fine grained and coarse
      grained control over expressing types with 
      variable mutability. For example:
    </p>
    <font size="small">
    <table fullwidth="yes" latex.colspec="c|c|c">
      <tbody>
	<tr lineafter="yes">
	  <td><p>Type</p></td>
	  <td><p>Instances</p></td>
	  <td><p>Non-Instances</p></td>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE>
		<mbTop>
		  <tvar/>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mbTop>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<pair>
		  <bool/>
		  <unit/>
		</pair>
	      </btypes:TYPE>,
	      <btypes:TYPE>
		<mutable>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mutable>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<pair>
		  <mutable>
		    <bool/>
		  </mutable>
		  <unit/>
		</pair>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
	<tr>
	  <td>
	    <p>
	      <btypes:TYPE>
		<mbFull>
		  <tvar/>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mbFull>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<pair>
		  <bool/>
		  <unit/>
		</pair>
	      </btypes:TYPE>,
	      <btypes:TYPE>
		<mutable>
		  <pair>
		    <mutable>
		      <bool/>
		    </mutable>
		    <mutable>
		      <unit/>
		    </mutable>
		  </pair>
		</mutable>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<pair>
		  <unit/>
		  <bool/>
		</pair>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<tr lineafter="yes">
	  <td/>
	  <td>
	    <p>
	      <btypes:TYPE>
		<pair>
		  <mutable>
		    <bool/>
		  </mutable>
		  <unit/>
		</pair>
	      </btypes:TYPE>,
	      <btypes:TYPE>
		<mbTop>
		  <tvar name="beta"/>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mbTop>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td/>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE>
		<mbFull>
		  <mutable>
		    <tvar/>
		  </mutable>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mbFull>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<mutable>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mutable>
	      </btypes:TYPE>,
	      <btypes:TYPE>
		<mutable>
		  <pair>
		    <bool/>
		    <mutable>
		      <unit/>
		    </mutable>
		  </pair>
		</mutable>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<pair>
		  <bool/>
		  <unit/>
		</pair>
	      </btypes:TYPE>,
	      <btypes:TYPE>
		<mbTop>
		  <tvar name="beta"/>
		  <pair>
		    <bool/>
		    <unit/>
		  </pair>
		</mbTop>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE>
		<mbFull>
		  <tvar/>
		  <ref>
		    <bool/>
		  </ref>
		</mbFull>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<ref>
		  <bool/>
		</ref>
	      </btypes:TYPE>,
	      <btypes:TYPE>
		<mutable>
		  <ref>
		    <bool/>
		  </ref>
		</mutable>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE>
		<ref>	
		  <mutable>
		    <bool/>
		  </mutable>
		</ref>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
      </tbody>
    </table>
    </font>
    <br/>
    <p>
      By embedding constraints within types, we obtain an elegant
      representation of constrained types that can be intuitively 
      presented to the user. For example, the expression
      <btypes:TYPE>
	<lambda>
	  <id/>
	  <paren>
	    <assign>
	      <deref>
		<fst>
		  <id/>
		</fst>
	      </deref>
	      <snd>
		<id/>
	      </snd>
	    </assign>
	  </paren>
	</lambda>
      </btypes:TYPE>
      can be typed as
      <btypes:TYPE>
	<fn>
	  <mbFull>
	    <tvar name="alpha"/>
	    <pair>
	      <ref>
		<mutable>
		  <tvar name="beta"/>
		</mutable>
	      </ref>
	      <mbFull>
		<tvar name="gamma"/>
		<tvar name="beta"/>
	      </mbFull>
	    </pair>
	  </mbFull>
	  <unit/>
	</fn>
      </btypes:TYPE>, rather than
      <btypes:TYPE>
	<ctype>
	  <fn>
	    <tvar name="alpha"/>
	    <unit/>
	  </fn>
	  <set>
	    <ceq>
	      <tvar name="alpha"/>
	      <pair>
		<ref>
		  <mutable>
		    <tvar name="beta"/>
		  </mutable>
		</ref>
		<tvar name="gamma"/>
	      </pair>
	    </ceq>
	    <ceq>
	      <tvar name="gamma"/>
	      <tvar name="beta"/>
	    </ceq>
	  </set>
	</ctype>
      </btypes:TYPE>. 
      Every type of the form
      <btypes:TYPE>
	<mbFull>
	  <stype/>
	  <ptype/>
	</mbFull>
      </btypes:TYPE> can be realized through a canonical
      representation using
      <btypes:TYPE>
	<mbTop>
	  <tvar/>
	  <ptype/>
	</mbTop>
      </btypes:TYPE> types. 
      Types of the form
      <btypes:TYPE>
	<mbFull>
	  <stype/>
	  <ptype/>
	</mbFull>
      </btypes:TYPE> not only provide a compact representation, but
      are also required during type inference.
      For example, the type
      <btypes:TYPE>
	<mbFull>
	  <tvar/>
	  <tvar name="beta"/>
	</mbFull>
      </btypes:TYPE> represents a type that is compatible 
      with   
      <btypes:TYPE>
	<tvar name="beta"/>
      </btypes:TYPE>, even if 
      <btypes:TYPE>
	<tvar name="beta"/>
      </btypes:TYPE> later resolves to a more concrete (ex: pair)
      type.
      The grammar does not allow unnecessarily complex types such as
      <btypes:TYPE>
	<mutable>
	  <paren>
	    <mbTop>
	      <tvar/>
	      <bool/>
	    </mbTop>
	  </paren>
	</mutable>
      </btypes:TYPE>,
      <btypes:TYPE>
	<mbTop>
	  <tvar name="beta"/>
	  <mbFull>
	    <tvar/>
	    <bool/>
	  </mbFull>
	</mbTop>
      </btypes:TYPE> <foreignphrase>etc.</foreignphrase>
    </p>
    <p>
      Due to copy compatibility at argument and return positions, two
      function types are <em>equal</em> regardless of the shallow
      mutability of the argument and return types. 
      Therefore, we follow a convention that all function types must be
      written with immutable types at copy compatible positions. The
      intuition here is that type of a function must be described in
      the interface form, and must hide the ``internal'' mutability
      information. For example, the function  
      <btypes:TYPE> 
	<lambda>
	  <id name="x"/>
	  <paren>
	    <assign>
	      <id name="x"/>
	      <true/>
	    </assign>
	  </paren>
	</lambda>
      </btypes:TYPE>, has external type 
      <btypes:TYPE> 
	<fn>
	  <bool/>
	  <unit/>
	</fn>
      </btypes:TYPE> even though the internal type is
      <btypes:TYPE> 
	<fn>
	  <mutable>
	    <bool/>
	  </mutable>
	  <unit/>
	</fn>
      </btypes:TYPE>.
    </p>
    <p>
      <btypes:TYPE> 
	<language/>
      </btypes:TYPE> is a let-polymorphic
      language. At a let boundary, we would like to quantify over
      variables that range over mutability, in order to achieve
      mutability polymorphism. The next sections discuss certain
      complications that arise during the inference of such types,
      present our solution to the problem.
    </p>
    <p>
      <leadin>Soundness implications</leadin>
      Like ML,
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> enforces the
      value restriction&nbsp;<cite ref="wrightValRes1995"/> to
      preserve soundness of polymorphic typing. This
      means that the type of 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> 
      in 
      <btypes:TYPE>
	<let>
	  <id/>
	  <aExpr num="1"/>
	  <aExpr num="2"/>
	</let>
      </btypes:TYPE> can only be generalized if 
      <btypes:TYPE>
	<aExpr num="1"/>
      </btypes:TYPE> is an <em>immutable</em> syntactic value.
      <!-- As is customary,
      values 
      <btypes:TYPE>
	<aVal/>
      </btypes:TYPE>, 
      Variables, and pairs of the above are considered syntactic
      values in
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>. -->
      Due to the presence of unboxed mutability, we must add the
      immutable qualifier to the syntactic value clause.
      For example, in the expression
      <btypes:TYPE>
	<let>
	  <id name="id"/>
	  <lambda>
	    <id/>
	    <id/>
	  </lambda>
	</let>
      </btypes:TYPE>, the type of 
      <btypes:TYPE>
	<id name="id"/>
      </btypes:TYPE> before generalization is
      <btypes:TYPE>
	<mbFull>
	  <tvar name="beta"/>
	  <fn>
	    <tvar/>
	    <tvar/>
	  </fn>
	</mbFull>
      </btypes:TYPE>. However, giving
      <btypes:TYPE>
	<id name="id"/>
      </btypes:TYPE> the generalized type
      <btypes:TYPE>
	<TS>
	  <grouping>
	    <tvar name="alpha"/>
	    <tvar name="beta"/>
	  </grouping>
	  <mbFull>
	    <tvar name="beta"/>
	    <fn>
	      <tvar/>
	      <tvar/>
	    </fn>
	  </mbFull>
	</TS>
      </btypes:TYPE> is unsound, since it permits
      expressions such as 
      <btypes:TYPE>
	<let>
	  <id name="id"/>
	  <lambda>
	    <id/>
	    <id/>
	  </lambda>
	  <Pair>
	    <assign>
	      <id name="id"/>
	      <lambda>
		<id/>
		<true/>
	      </lambda>
	    </assign>
	    <apply>
	      <id name="id"/>
	      <Unit/>
	    </apply>
	  </Pair>
	</let>
      </btypes:TYPE> to type check.
      We can give
      <btypes:TYPE>
	<id name="id"/>
      </btypes:TYPE> either the polymorphic type
      <btypes:TYPE>
	<forall>
	  <tvar/>
	  <fn>
	    <tvar/>
	    <tvar/>
	  </fn>
	</forall>
      </btypes:TYPE>, or the monomorphic type
      <btypes:TYPE>
	<mbpair>
	  <tvar name="beta"/>
	  <fn>
	    <tvar/>
	    <tvar/>
	  </fn>
	</mbpair>	  
      </btypes:TYPE>. However, neither is a principal type for
      <btypes:TYPE>
	<id name="id"/>
      </btypes:TYPE>.
    </p>
    <p>
      <leadin>Overloading Polymorphism</leadin>
      Due to the above interaction of polymorphism and unboxed
      mutability, a traditional HM-style inference algorithm cannot 
      defer decisions about the mutability
      of types past their generalization. Therefore, current
      algorithms fix the mutability of types before generalization
      based on certain heuristics &mdash; thus sacrificing 
      completeness&nbsp;<cite ref="sridhar2006plos"/>. 
      In order to alleviate this problem, we propose the use of 
      constrained types that are range over both mutability and
      polymorphism.
    </p>
    <p>
      We introduce a new form of constraint
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind/>
	  <type/>
	</pcst>
      </btypes:TYPE>, which enforces consistency restrictions on
      instantiations of generalized types.
      The constraint 
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind/>
	  <type/>
	</pcst>
      </btypes:TYPE> requires that the identifier 
      <btypes:TYPE> 
	<id/>
      </btypes:TYPE> must only be instantiated according to the kind
      <btypes:TYPE> 
	<lKind/>
      </btypes:TYPE>, where
      <btypes:TYPE> 
	<lKind/>
      </btypes:TYPE>&nbsp;=&nbsp;<btypes:TYPE> 
	<lKind k="mono"/>
      </btypes:TYPE>&nbsp;or&nbsp;<btypes:TYPE> 
	<lKind k="poly"/>
      </btypes:TYPE>. If 
      <btypes:TYPE> 
	<eq>
	  <lKind/>
	  <lKind k="mono"/>
	</eq>
      </btypes:TYPE>, the instantiation of 
      <btypes:TYPE> 
	<id/>
      </btypes:TYPE> must be monomorphic. That is, all uses of 
      <btypes:TYPE> 
	<id/>
      </btypes:TYPE> must instantiate
      <btypes:TYPE> 
	<type/>
      </btypes:TYPE> to the same type
      <btypes:TYPE> 
	<type dash="'"/>
      </btypes:TYPE>. Here, 
      <btypes:TYPE> 
	<type dash="'"/>
      </btypes:TYPE> is permitted to be a mutable type. 
      If 
      <btypes:TYPE> 
	<eq>
	  <lKind/>
	  <lKind k="poly"/>
	</eq>
      </btypes:TYPE>, different uses of 
      <btypes:TYPE> 
	<id/>
      </btypes:TYPE> can instantiate 
      <btypes:TYPE> 
	<type/>
      </btypes:TYPE> differently, but all such instantiations must be
      immutable.
      At the point of definition (<progident>let</progident>), if the
      exact instantiation kind of a variable is unknown, we add the
      constraint
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind k="var"/>
	  <type/>
	</pcst>
      </btypes:TYPE>, where
      <btypes:TYPE> 
	<lKind k="var"/>
      </btypes:TYPE> ranges over
      <btypes:TYPE> 
	<lKind k="mono"/>
      </btypes:TYPE> and
      <btypes:TYPE> 
	<lKind k="poly"/>
      </btypes:TYPE>. The correct instantiation kind is 
      determined later based on the uses of  
      <btypes:TYPE> 
	<id/>
      </btypes:TYPE>, and consistency semantics are enforced
      accordingly. 
    </p>
    <p>
      In this approach, the definition of 
      <btypes:TYPE> 
	<id name="id"/>
      </btypes:TYPE> will be given the principal constrained type:
      <br/>
      <btypes:TYPE> 
	<space n="8"/>
	<let>
	  <id name="id"/>
	  <lambda>
	    <id/>
	    <id/>
	  </lambda>
	  <aExpr/>
	</let>
	<space n="10"/>
	<tqExpr>
	  <id name="id"/>
	  <btypes:TYPE>
	    <TS>
	      <grouping>
		<tvar name="alpha"/>
		<tvar name="beta"/>
	      </grouping>
	      <ctype>
		<mbFull>
		  <tvar name="beta"/>
		  <fn>
		    <tvar/>
		    <tvar/>
		  </fn>
		</mbFull>
		<set>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <mbFull>
		      <tvar name="beta"/>
		      <fn>
			<tvar/>
			<tvar/>
		      </fn>
		    </mbFull>
		  </pcst>
		</set>
	      </ctype>
	    </TS>
	  </btypes:TYPE>
	</tqExpr>
      </btypes:TYPE>
      <br/>
      Every time
      <btypes:TYPE> 
	<id name="id"/>
      </btypes:TYPE> is instantiated to type
      <btypes:TYPE> 
	<type dash="'"/>
      </btypes:TYPE> in
      <btypes:TYPE> 
	<aExpr/>
      </btypes:TYPE>, the constraints
      <btypes:TYPE> 
	<pcst>
	  <id name="id"/>
	  <lKind k="var"/>
	  <type dash="'"/>
	</pcst>
      </btypes:TYPE> are collected.
      <btypes:TYPE> 
	<aExpr/>
      </btypes:TYPE> is declared type correct only if the set of all
      instantiated constraints are consistent for some
      <btypes:TYPE> 
	<lKind k="var"/>
      </btypes:TYPE>. Note that we do not quantify over
      <btypes:TYPE> 
	<lKind k="var"/> 
      </btypes:TYPE>.
    </p> 
    <font size="small">
    <table fullwidth="yes" latex.colspec="c|c|c">
      <tbody>
	<tr lineafter="yes">
	  <td>
	    <p>Example of
	      <btypes:TYPE> 
		<aExpr/>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      Constraint set
	    </p>
	  </td>
	  <td>
	    <p>
	      Kind assignment
	    </p>
	  </td>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE> 
		<Pair>
		  <apply>
		    <id name="id"/>
		    <true/>
		  </apply>
		  <apply>
		    <id name="id"/>
		    <Unit/>
		  </apply>
		</Pair>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<set>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <fn>
		      <bool/>
		      <bool/>
		    </fn>
		  </pcst>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <fn>
		      <unit/>
		      <unit/>
		    </fn>
		  </pcst>
		</set>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<mapping>
		  <lKind k="var"/>
		  <lKind k="poly"/>
		</mapping>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE> 
		<assign>
		  <id name="id"/>
		  <lambda>
		    <id/>
		    <id/>
		  </lambda>
		</assign>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<set>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <mutable>
		      <fn>
			<tvar name="gamma"/>
			<tvar name="gamma"/>
		      </fn>
		    </mutable>
		  </pcst>
		</set>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<mapping>
		  <lKind k="var"/>
		  <lKind k="mono"/>
		</mapping>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE> 
		<Pair>
		  <apply>
		    <id name="id"/>
		    <true/>
		  </apply>
		  <assign>
		    <id name="id"/>
		    <lambda>
		      <id/>
		      <Unit/>
		    </lambda>
		  </assign>
		</Pair>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<set>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <fn>
		      <bool/>
		      <bool/>
		    </fn>
		  </pcst>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <mutable>
		      <fn>
			<unit/>
			<unit/>
		      </fn>
		    </mutable>
		  </pcst>
		</set>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <progident>Type Error</progident>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
	<tr lineafter="yes">
	  <td>
	    <p>
	      <btypes:TYPE> 
		<apply>
		  <id name="id"/>
		  <id name="id"/>
		</apply>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<set>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <mbFull>
		      <tvar name="beta" num="1"/>
		      <fn>
			<tvar name="alpha" num="1"/>
			<tvar name="alpha" num="1"/>
		      </fn>
		    </mbFull>
		  </pcst>
		  <pcst>
		    <id name="id"/>
		    <lKind k="var"/>
		    <mbFull>
		      <tvar name="beta" num="2"/>
		      <fn>
 			<tvar name="alpha" num="2"/>
			<tvar name="alpha" num="2"/>
		      </fn>
		    </mbFull>
		  </pcst>
		</set>
	      </btypes:TYPE>
	    </p>
	  </td>
	  <td>
	    <p>
	      <btypes:TYPE> 
		<mapping>
		  <lKind k="var"/>
		  <grouping>
		    <lKind k="mono"/>
		    <text content=" or "/>
		    <lKind k="poly"/>
		  </grouping>
		</mapping>
	      </btypes:TYPE>
	    </p>
	  </td>
	</tr>
	<!-- Row -->
      </tbody>
    </table>
    </font>
    <br/>
    <p>
      The final case type checks with either kind, under the 
      type assignments 
      (<btypes:TYPE> 
	<eq>
	  <tvar name="alpha" num="1"/>
	  <tvar name="alpha" num="2"/>
	</eq>
      </btypes:TYPE>,
      <btypes:TYPE> 
	<eq>
	  <tvar name="beta" num="1"/>
	  <tvar name="beta" num="2"/>
	</eq>
      </btypes:TYPE>) if
      <btypes:TYPE> 
	<mapping>
	  <lKind k="var"/>
	  <lKind k="mono"/>
	</mapping>
      </btypes:TYPE> and
      (<btypes:TYPE> 
	<eq>
	  <tvar name="beta" num="1"/>
	  <fn>
	    <tvar name="alpha" num="1"/>
	    <tvar name="alpha" num="1"/>
	  </fn>
	</eq>
      </btypes:TYPE>,
      <btypes:TYPE> 
	<eq>
	  <tvar name="beta" num="2"/>
	  <fn>
	    <tvar name="alpha" num="2"/>
	    <tvar name="alpha" num="2"/>
	  </fn>
	</eq>
      </btypes:TYPE>) if
      <btypes:TYPE> 
	<mapping>
	  <lKind k="var"/>
	  <lKind k="poly"/>
	</mapping>
      </btypes:TYPE>.
      The intuition behind 
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind k="var"/>
	  <type/>
	</pcst>
      </btypes:TYPE> constraints is to achieve a form of
      <em>overloading</em> over polymorphism and mutability.
      We can think of 
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind k="var"/>
	  <type/>
	</pcst>
      </btypes:TYPE> as a 
      type class&nbsp;<cite ref="jones1995qualtypes"/> constraint that
      has exactly one possible mutable instance
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind k="mono"/>
	  <type num="m"/>
	</pcst>
      </btypes:TYPE>, or an infinite number of
      <btypes:TYPE> 
	<pcst>
	  <id/>
	  <lKind k="poly"/>
	  <type num="p"/>
	</pcst>
      </btypes:TYPE> instances where all types
      <btypes:TYPE> 
	<types num="p"/>
      </btypes:TYPE> are immutable.
    </p>
    <p>
      In practice, once the correct kind of instantiation is inferred,
      the type scheme can be presented in a simplified form
      to the programmer. 
      For example, consider the expression
      <btypes:TYPE> 
	<let>
	  <id name="f"/>
	  <lambda>
	    <id/>
	    <if>
	      <deref>
		<id/>
	      </deref>
	      <Unit/>
	      <Unit/>
	    </if>
	  </lambda>
	  <Pair>
	    <apply>
	      <id name="f"/>
	      <id name="m"/>
	    </apply>
	    <apply>
	      <id name="f"/>
	      <id name="n"/>
	    </apply>
	  </Pair>
	</let>
      </btypes:TYPE>, where
      <btypes:TYPE> 
	<tqExpr>
	  <id name="m"/>
	  <ref>
	    <mutable>
	      <bool/>
	    </mutable>
	  </ref>
	</tqExpr>
      </btypes:TYPE> and
      <btypes:TYPE> 
	<tqExpr>
	  <id name="n"/>
	  <ref>
	    <bool/>
	  </ref>
	</tqExpr>
      </btypes:TYPE>.
      Here,
      <btypes:TYPE> 
	<tqExpr>
	  <id name="f"/>
	  <TS>
	    <grouping>
	      <tvar name="alpha"/>
	      <tvar name="beta"/>
	    </grouping>
	    <mbFull>
	      <tvar name="beta"/>
	      <fn>
		<ref>
		  <mbFull>
		    <tvar/>
		    <bool/>
		  </mbFull>
		</ref>
		<unit/>
	      </fn>
	    </mbFull>
	    <set>
	    <pcst>
	      <id name="f"/>
	      <lKind k="var"/>
	      <mbFull>
		<tvar name="beta"/>
		<fn>
		  <ref>
		    <mbFull>
		      <tvar/>
		      <bool/>
		    </mbFull>
		  </ref>
		  <unit/>
		</fn>
	      </mbFull>
	    </pcst>
	    </set>
	  </TS>
	</tqExpr>
      </btypes:TYPE>. However, based on the polymorphic usage, we
      conclude that
      <btypes:TYPE> 
	<mapping>
	  <lKind k="var"/>
	  <lKind k="poly"/>
	</mapping>
      </btypes:TYPE>.
      We can now simplify the type scheme of 
      <btypes:TYPE> 
	<id name="f"/>
      </btypes:TYPE> to obtain
      <btypes:TYPE> 
	<tqExpr>
	  <id name="f"/>
	  <TS>
	    <tvar name="alpha"/>
	    <fn>
	      <ref>
		<mbFull>
		  <tvar/>
		  <bool/>
		</mbFull>
	      </ref>
	      <unit/>
	    </fn>
	  </TS>
	</tqExpr>
      </btypes:TYPE>.
      Since all function types are  immutable, the mutability of the
      argument type need not be fixed, thus preserving mutability
      polymorphism. 
    </p>
    <p>
      In summary, we have used a system of constrained types to
      design a principle polymorphic type inference system that meets
      all of the design goals set at the beginning of this section. In
      the next section, we present a formal description of our type
      system and inference algorithm. 
    </p>
    <!-- <btypes:TYPE> 
	<let>
	  <id name="map"/>
	  <lambda>
	    <id name="f"/>
	    <lambda>
 	      <id name="x"/>
	      <Pair>
		<apply>
		  <id name="f"/>
		  <fst>
		    <id name="x"/>
		  </fst>
		</apply>
		<apply>
		  <id name="f"/>
		  <fst>
		    <id name="x"/>
		  </fst>
		</apply>
	      </Pair>
	    </lambda>
	  </lambda>
	  <Pair>
	    <map>
	      <id name="id"/>
	      <Pair>
		<true/>
		<false/>
	      </Pair>
	    </map>
	    <map>
	      <id name="id"/>
	      <Pair>
		<Unit/>
		<Unit/>
	      </Pair>
	    </map>
	  </Pair>
	</let>
      </btypes:TYPE> -->
  </sect1>
  <sect1 id="formal">
    <title>Formalization</title>
    <xi:include href="include/complete/grammar.xmli"/>
    <p>      
      In order to formalize the semantics of
      <btypes:TYPE>
	<language/>
      </btypes:TYPE>, we extend the calculus with stack and heap
      locations. Heap locations are first class values, but stack
      locations are not. Further, we annotate all 
      <progident>let</progident> expressions with their appropriate
      kinds &mdash;
      <btypes:TYPE>
        <let kind="m"/>
      </btypes:TYPE>: monomorphic, possibly mutable
      definition, and
      <btypes:TYPE>
        <let kind="p"/>
      </btypes:TYPE>: polymorphic definitions.
      The two kinds of <progident>let</progident> expressions have
      different execution semantics. This distinction is
      similar to Smith and Volpano's Polymorphic-C&nbsp;<cite
        ref="Smith1998polymorphicC"/>. However, unlike 
      Polymorphic-C, let-kind is <em>meta syntax</em>, and is not a
      part of the input program.
      The correct kind of <progident>let</progident> is
      inferred from the static type information.
    </p>
    <xi:include href="include/complete/opsem.xmli"/>
    <p>
      <leadin>Dynamic Semantics</leadin> The system state is
      represented by the triple
      <btypes:TYPE>
	<opState>
	  <stack/>
	  <heap/>
	  <aExpr/>
	</opState>
      </btypes:TYPE>
      consisting of the stack
      <btypes:TYPE>
	<stack/>
      </btypes:TYPE>, the heap
      <btypes:TYPE>
	<heap/>
      </btypes:TYPE>, and the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> to be
      evaluated. Evaluation itself is a two place relationship   
      <btypes:TYPE>
	<eval>
	  <opState>
	    <stack/>
	    <heap/>
	    <aExpr/>
	  </opState>
	  <opState>
	    <stack dash="'"/>
	    <heap dash="'"/>
	    <aExpr dash="'"/>
	  </opState>
	</eval>
      </btypes:TYPE>
      that denotes transformation in the system state due to a single
      step of execution.
      Figure&nbsp;<xref ref="dyn_sem_horz"/> shows the evaluation
      rules for our core language. We assume that the program is
      alpha-converted so that there are no name collisions due to
      inner bindings.  Following the theoretical
      development in&nbsp;<cite ref="Grossman2006qtypes"/>, we give
      separate execution semantics for left evaluation
      (execution of left expressions
      <btypes:TYPE>
	<lExp/>
      </btypes:TYPE> on the LHS of an assignment, denoted by
      <btypes:TYPE>
	<levalOp/>
      </btypes:TYPE>) and 
      right evaluation
      (<btypes:TYPE>
	<evalOp/>
      </btypes:TYPE>) respectively. 
    </p>
    <p>
      Since the E-Dup and E-^ rules work only on the heap, we can only
      capture references to heap cells. Stack locations cannot escape
      beyond their scope since E-Rval rule performs implicit value
      extraction from stack locations in rvalue contexts. State
      updates can be performed 
      either on the stack or on the heap&nbsp;(E-:=* rules). The stack
      is modeled as a pseudo-heap. 
      This enables us to abstract away details such as
      closure-construction and garbage collection while illustrating
      the core semantics, as they can later be reified
      independently.
    </p>
    <!-- <p>
      <leadin>Static Semantics</leadin>
      A substitution of Z for Y in X is written as:
      <btypes:TYPE>
	<subst>
	  <text content="X"/>
	  <text content="Y"/>
	  <text content="Z"/>          
	</subst>
      </btypes:TYPE>.
      The application of a substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE> on X is written as
      <btypes:TYPE>
	<Subst>
	  <aSubMap/>
	  <text content="X"/>
	</Subst>
      </btypes:TYPE>. 
      We represent mathematical properties as: 
      <btypes:TYPE>
	<models name="property">
	  <text content="assumption"/>
	  <text content="subject"/>
	</models>
      </btypes:TYPE>.
      In our algebra of types, the mutable type constructor is
      idempotent. That is, we have the equivalence: 
      <btypes:TYPE>
	<equiv>
	  <mutable>
	    <mutable>
	      <type/>
	    </mutable>
	  </mutable>
	  <mutable>
	    <type/>
	  </mutable>
	</equiv>
      </btypes:TYPE>.
      We define the operators
      <btypes:TYPE><maxzOp/></btypes:TYPE> and
      <btypes:TYPE><minzOp/></btypes:TYPE> that increase or
      decrease the mutability of a type as:
      <btypes:TYPE>
	<text content="  "/>
	<eq>
	  <maxz>
	    <mutable>
	      <type/>
	    </mutable>
	  </maxz>
	  <mutable>
	    <type/>
	  </mutable>
	</eq>
	<text content=", "/>
	<eq>
	  <maxz>
	    <type/>
	  </maxz>
	  <mutable>
	    <type/>
	  </mutable>
	</eq>
	<text content=" and "/>
	<eq>
	  <minz>
	    <mutable>
	      <type/>
	    </mutable>
	  </minz>
	  <type/>
	</eq>
	<text content=", "/>
	<eq>
	  <minz>
	    <type/>
	  </minz>
	  <type/>
	</eq>
      </btypes:TYPE>
      , where
      <btypes:TYPE>
	<neq>
	  <type/>
	  <mutable>
	    <type dash="'"/>
	  </mutable>
	</neq>
      </btypes:TYPE>.
      Note that
      <btypes:TYPE>
	<forall>
	  <type/>
	  <ceq>
	    <minz>
	      <type/>
	    </minz>
	    <type/>
	    <maxz>
	      <type/>
	    </maxz>
	  </ceq>
	</forall>
	<text content="."/>
      </btypes:TYPE>	  
    </p>
    <p>
      Copy compatibility is realized in the type system by using
      <em>copy coercion</em> rules that are similar to
      subtyping rules (the rules beginning with ``S'' in
      Figure&nbsp;<xref ref="decl_all_rules"/>). Copy compatibility 
      can be written in terms of these coercions as 
      <btypes:TYPE>
	<ceq>
	  <type num="1"/>
	  <type num="2"/>
	</ceq>
      </btypes:TYPE>
      <em>iff</em>
      <btypes:TYPE>
	<Tsub>
	  <type num="1"/>
	  <minz>
	    <type num="2"/>
	  </minz>
	</Tsub>
      </btypes:TYPE>
      <em>iff</em>
      <btypes:TYPE>
	<Tsub>
	  <maxz>
	    <type num="1"/>
	  </maxz>
	  <type num="2"/>
	</Tsub>
      </btypes:TYPE>.
      The S-Ref rule ensures that copy compatibility does not
      extend beyond a ref-boundary. Since two function types are
      equal regardless of the shallow mutability of the argument and
      return positions, we write all function types in normalized
      form.  The (contravariant) argument type is written in the
      maximally immutable form (devoid of shallow mutability), and the
      (covariant) return type is written in the maximally mutable
      form.  This ensures that the ``outer'' type of a function is
      maximally permissive with respect to mutability. The S-Fn rule
      therefore is invariant in terms of its arguments and return
      types. [This normalization is different from the type displayed to the
      user, which is discussed in section&nbsp;<xref ref="proposal"/>.]  
    </p>
    <p>
      During type inference, if we infer the type:
      <btypes:TYPE>
	<fn>
	  <minz>
	    <type num="arg"/>
	  </minz>
	  <maxz>
	    <type num="ret"/>
	  </maxz>            
	</fn>
      </btypes:TYPE>
      as the type of a function, its normalization could
      later be violated due to substitution of type-variables. 
      Therefore, we define the 
      <btypes:TYPE>
	<floor>
	  <type/>
	</floor>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<ceil>
	  <type/>
	</ceil>
      </btypes:TYPE>
      ``meta-constructors'' which (respectively) minimize and
      maximize the mutability of a type, but are interpreted
      lazily. The meta-constructors are also idempotent in our
      algebra of types.
  </p> -->
    <xi:include href="include/complete/operators.xmli"/>
    <xi:include href="include/complete/type.xmli"/>
    <!-- <p>    
      <leadin>Declarative Type Rules</leadin>
      The declarative type rules for our core language are given in 
      Figure&nbsp;<xref ref="decl_all_rules"/>. The standard type
    judgment  
      <btypes:TYPE>
	<TDjudge>
	  <aExpr/>
	  <type/>
	</TDjudge>
      </btypes:TYPE> is understood as: given a binding environment 
      <btypes:TYPE>
	<gamma/>
      </btypes:TYPE> and store typing
      <btypes:TYPE>
	<store/>
      </btypes:TYPE>, the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> has type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE>. We write 
      <btypes:TYPE>
	<Tsub>
	  <aExpr/>                  
	  <type/>                  
	</Tsub>
      </btypes:TYPE> as a shorthand for:
      <btypes:TYPE>
	<tqExpr>
	  <aExpr/>                  
	  <type dash="'"/>                  
	</tqExpr>
	<text content=", "/>
	<Tsub>
	  <type dash="'"/>
	  <type/>
	</Tsub>
      </btypes:TYPE>, for some type
      <btypes:TYPE>
	<type dash="'"/>                  
      </btypes:TYPE>.
      In the type rules, we introduce copy coercions at
      all positions where copy compatibility is applicable.
      Lvalue restrictions given in section&nbsp;<xref
	ref="mut_model"/> are enforced by the judgment 
      <btypes:TYPE>
	<judgeOp name="lval"/>
      </btypes:TYPE>, and type generalization at a
      <progident>let</progident> is decided by the judgment 
      <btypes:TYPE>
	<judgeOp name="gen"/>
      </btypes:TYPE>.
    </p>
    <p>
      We prove the soundness of our type system by demonstrating
      subject reduction. A full proof can be
      found in&nbsp;<cite ref="sridhar2007formal"/>.
    </p>
    <p>
      <font size="small">
	<leadin>Definition 1 (Heap and Stack typing)</leadin>
	<em>
	  A heap <btypes:TYPE><heap/></btypes:TYPE> and a stack
	  <btypes:TYPE><stack/></btypes:TYPE> are said to be
	  <em>well typed</em> with respect to a binding context 
	  <btypes:TYPE><gamma/></btypes:TYPE> and store typing
	  <btypes:TYPE><store/></btypes:TYPE>, and written 
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge>
	  </btypes:TYPE>
	  if
	  (1) 
	  <btypes:TYPE>
	    <eq>
	      <dom><store/></dom>
	      <unin>
		<dom><heap/></dom>
		<dom><stack/></dom>
	      </unin>
	    </eq>
	  </btypes:TYPE>,
	  (2)	  
	  <btypes:TYPE>
	    <Forall>
	      <in>
		<hLoc/>
		<dom><heap/></dom>
	      </in>
	    </Forall>
	  </btypes:TYPE>,
	  <br/>
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Tsub>
		<mapsto><heap/><hLoc/></mapsto>
		<mapsto><store/><hLoc/></mapsto>
	      </Tsub>
	    </Sjudge>            
	  </btypes:TYPE>,
	  and 
	  (3)
	  <btypes:TYPE>
	    <forall>
	      <in>
		<sLoc/>
		<dom><stack/></dom>
	      </in>
	    </forall>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <Tsub>
		<mapsto><stack/><sLoc/></mapsto>
		<mapsto><store/><sLoc/></mapsto>
	      </Tsub>
	    </Sjudge>            
	  </btypes:TYPE>.
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Lemma 1 (Preservation)</leadin>
	<em>
	  If
	  <btypes:TYPE>          
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	    <text content=" and "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge> 
	    <text content=" then, "/>    
	  </btypes:TYPE>
	  <br/>
	  (1) If
	  <btypes:TYPE>
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content=", then "/>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>
	    <text content=" such that "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <tqExpr>
		<aExpr dash="'"/>
		<type/>
	      </tqExpr>                    
	    </Sjudge>
	    <text content=" and "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	    <text content="."/>
	  </btypes:TYPE>              
	  <br/>
	  (2) If
	  <btypes:TYPE>          
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content=", then "/>
	    <Exists/>
	    <supeq>
	      <store dash="'"/>
	      <store/>
	    </supeq>                
	    <text content=" such that "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <Tsub>
		<aExpr dash="'"/>
		<type dash="'"/>
	      </Tsub>                    
	    </Sjudge>
	    <text content=", "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store dash="'"/>
	      </assume>
	      <plus>
		<heap dash="'"/>
		<stack dash="'"/>
	      </plus>
	    </Sjudge>
	    <text content=" and "/>
	    <eq>
	      <minz>
		<type/>
	      </minz>
	      <minz>
		<type dash="'"/>
	      </minz>
	    </eq>
	    <text content="."/>
	  </btypes:TYPE>
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Lemma 2 (Progress)</leadin>
	<em>
	  If
	  <btypes:TYPE>
	    <aExpr/>
	    <text content=" is a closed, well typed term, "/> 
	    <text content="that is, "/> 
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	    <text content=" for some "/> 
	    <type/>
	    <text content=" and "/> 
	    <store/>
	    <text content=", given any heap "/> 
	    <heap/>
	    <text content=" and stack "/> 
	    <stack/>
	    <text content=" such that "/> 
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge> 
	    <text content=", "/>            
	  </btypes:TYPE>
	  <br/>
	  (1) If
	  <btypes:TYPE>
	    <Sjudge name="lval">
	      <assume/>
	      <aExpr/>
	    </Sjudge>
	    <text content=", then "/>              
	    <aExpr/>
	    <text content=" is either a valid lvalue "/> 
	    <lVal/>
	    <text content=" (that is, "/>
	    <eq>
	      <lVal/>
	      <sLoc/>
	    </eq>
	    <text content=", "/>
	    <in>
	      <sLoc/>
	      <dom>
		<stack/>
	      </dom>
	    </in>
	    <text content=" or "/> 
	    <eq>
	      <lVal/>
	      <deref>
		<hLoc/>
	      </deref>
	    </eq>
	    <text content=", "/>
	    <in>
	      <hLoc/>
	      <dom>
		<heap/>
	      </dom>
	    </in>
	    <text content=") or else "/>
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>               
	    <leval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </leval>
	    <text content="."/>   
	  </btypes:TYPE>
	  <br/>
	  (2)
	  <btypes:TYPE>
	    <aExpr/>
	    <text content=" is a value "/> 
	    <aVal/>
	    <text content=" or else "/> 
	    <Exists>
	      <aExpr dash="'"/>
	      <stack dash="'"/>
	      <heap dash="'"/>
	    </Exists>
	    <text content=" such that "/>               
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content="."/>
	  </btypes:TYPE>
	</em>
	<br/>
	<em>Proof.</em>
	(Lemma 1 and 2)
	By induction on the derivation of 
	<btypes:TYPE>
	  <Sjudge>
	    <assume>
	      <gamma/>
	      <store/>
	    </assume>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </Sjudge>
	</btypes:TYPE>.
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Definition 2 (Stuck State)</leadin>
	<em>
	  A system state 
	  <btypes:TYPE>
	    <opState>
	      <stack/>
	      <heap/>
	      <aExpr/>
	    </opState>
	  </btypes:TYPE>
	  is said to be <term>stuck</term> if
	  <btypes:TYPE>
	    <neq>
	      <aExpr/>
	      <aVal/>
	    </neq>
	  </btypes:TYPE>
	  and there are no 
	  <btypes:TYPE>
	    <stack dash="'"/>
	    <text content=", "/>
	    <heap dash="'"/>
	    <text content=", and "/>
	    <aExpr dash="'"/>
	  </btypes:TYPE>   
	  such that 
	  <btypes:TYPE>
	    <eval>
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	  </btypes:TYPE>.
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Theorem 1 (Type Soundness)</leadin>
	<em>
	  Let 
	  <btypes:TYPE>
	    <evalOp many="yes"/>
	  </btypes:TYPE> denote the reflexive-transitive-closure of 
	  <btypes:TYPE>
	    <evalOp/>
	  </btypes:TYPE>.          
	  If 
	  <btypes:TYPE>
	    <Sjudge>
	      <assume>
		<Empty/>
		<store/>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </Sjudge>
	    <text content=" and "/>
	    <Sjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <plus>
		<heap/>
		<stack/>
	      </plus>
	    </Sjudge> 
	    <text content=" and "/>
	    <eval many="yes">
	      <opState>
		<stack/>
		<heap/>
		<aExpr/>
	      </opState>
	      <opState>
		<stack dash="'"/>
		<heap dash="'"/>
		<aExpr dash="'"/>
	      </opState>
	    </eval>
	    <text content=" then "/>
	    <opState>
	      <stack dash="'"/>
	      <heap dash="'"/>
	      <aExpr dash="'"/>
	    </opState>
	    <text content=" is not stuck."/>            
	  </btypes:TYPE>
	  That is, execution of a well typed expression cannot lead to
	  a stuck state. 
	</em>
	<br/>
	<em>Proof:</em>
	By straightforward induction on the
	length of   
	<btypes:TYPE>
	  <evalOp many="yes"/>
	</btypes:TYPE>.
      </font>
  </p> -->
    <xi:include href="include/complete/infer.xmli"/>
    <xi:include href="include/complete/unify.xmli"/>
    <!-- <p>
      <leadin>Type Inference Algorithm</leadin>	
    </p>
    <p>
      <font size="small">
	<leadin>Definition 3 (Type Inference)</leadin>
	<em>
	  Type inference is a program
	  transformation that accepts a program in which
	  <progident>let</progident> expressions are not annotated
	  with their kinds, and returns the same programs in which
	  <progident>let</progident> expressions are annotated with
	  their kinds and all expressions are annotated with their
	  types.
	</em>
      </font>
    </p>
    <p>
      The type inference algorithm is as shown in
      Figure&nbsp;<xref ref="hm_infer"/>. 
      The inference judgment 
      <btypes:TYPE>
	<TIjudge>
	  <assume>
	    <gamma/>
	    <store/>
	  </assume>
	  <conclude>
	    <tqExpr>
	      <aExpr/>
	      <type/>
	    </tqExpr>
	  </conclude>
	  <propagate>
	    <aSubMap/>
	  </propagate>
	</TIjudge>
      </btypes:TYPE>
      should be understood as: given the binding context
      <btypes:TYPE><gamma/></btypes:TYPE> and the store typing
      <btypes:TYPE><store/></btypes:TYPE>, we infer the type 
      <btypes:TYPE><type/></btypes:TYPE> for the expression 
      <btypes:TYPE><aExpr/></btypes:TYPE>.
      <btypes:TYPE><aSubMap/></btypes:TYPE> is list of substitutions 
      obtained by unifications performed during inference, and must be
      propagated to further derivations. The judgment
      <btypes:TYPE>
	<models name="new">
	  <assume/>
	  <tvars name="alpha"/>
	</models>
      </btypes:TYPE> identifies new type variables.
    </p>
    <p>
      The I-Lambda rule uses
      the meta-constructors defined above to infer a
      normalized type for functions. The I-App rule infers copy
      compatible types by introducing maybe types at three
      positions &mdash; the function type itself (by unifying 
      <btypes:TYPE>
	<Subst>
	  <aSubMap num="2"/>
	  <type num="1"/>
	</Subst>
      </btypes:TYPE> and
      <btypes:TYPE>
	<mbpair>
	  <tvar name="beta"/>
	  <fn>
	    <floor>
	      <tvar name="delta"/>
	    </floor>
	    <ceil>
	      <tvar name="alpha"/>
	    </ceil>
	  </fn>
	</mbpair>
      </btypes:TYPE>), the argument type (by unifying 
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE> with 
      <btypes:TYPE>
	<mbpair>
	  <tvar name="gamma"/>
	  <floor>
	    <Subst>
	      <aSubMap num="1" dash="'"/>
	      <tvar name="delta"/>
	    </Subst>
	  </floor>
	</mbpair>
      </btypes:TYPE>) and the return type (through	
      <btypes:TYPE>
	<mbpair>
	  <tvar name="epsiv"/>
	  <Subst>
	    <aSubMap num="2" dash="'"/>
	    <minz>
	      <Subst>
		<aSubMap num="1" dash="'"/>
		<tvar name="alpha"/>
	      </Subst>
	    </minz>
	    <type/>
	  </Subst>
	</mbpair>	    
      </btypes:TYPE>).
      The hint for the return type
      <btypes:TYPE>
	<type/>
      </btypes:TYPE> is computed in a way that masks the internal
      mutability of a function, but preserves the mutability
      introduced by actual arguments.(see section&nbsp;<xref
	ref="proposal"/>). We start with an
      immutable version of the function's return type
      <btypes:TYPE>
	<minz>
	  <Subst>
	    <aSubMap num="1" dash="'"/>
	    <tvar name="alpha"/>
	  </Subst>
	</minz>
      </btypes:TYPE>, and then substitute the result of
      the argument unification to obtain
      <btypes:TYPE>
	<Subst>
	  <aSubMap num="2" dash="'"/>
	  <minz>
	    <Subst>
	      <aSubMap num="1" dash="'"/>
	      <tvar name="alpha"/>
	    </Subst>
	  </minz>
	  <type/>
	</Subst>
      </btypes:TYPE> as the hint for the return type.
      Similarly, the I-If rule infers copy compatible types
      for the two branches and the result. It calculates the most
      immutable type as the hint for the result type by computing
      the join&nbsp;<cite ref="pierce2002TypesBook"/> of 
      <btypes:TYPE>
	<Subst>
	  <aSubMap dash="'"/>
	  <type num="2"/>
	</Subst>
	<text content=" and "/>
	<Subst>
	  <aSubMap dash="'"/>
	  <type num="3"/>
	</Subst>
      </btypes:TYPE> (note that two copy compatible types always
      have a join). Other rules are similar.
    </p>
    <p>
      Unification rules are as shown in 
      Figure&nbsp;<xref ref="hm_unify"/>.
      The unification judgment
      <btypes:TYPE>
	<UNIFY>
	  <type num="1"/>                  
	  <type num="2"/>
	  <aSubMap/>
	</UNIFY>
      </btypes:TYPE>
      is understood as: 
      <btypes:TYPE>
	<type num="1"/>                  
      </btypes:TYPE>
      unifies with
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      under the substitution
      <btypes:TYPE>
	<aSubMap/>
      </btypes:TYPE>. 
      The function 
      <btypes:TYPE>
	<Xform name="real" isEntity="yes">
	  <type/>
	</Xform>
      </btypes:TYPE> introduces normalizing meta constructors
      around types so that equivalences such as 
      <btypes:TYPE>
	<equiv>
	  <bool/>
	  <floor>
	    <bool/>
	  </floor>
	</equiv>
      </btypes:TYPE> are maintained. The 
      <btypes:TYPE>
	<judgeOp name="u"/>
      </btypes:TYPE> rules perform the actual unification. 
      The interesting cases are U-Mb-Mb and
      U-Mb-Oth. The U-Mb-Oth rule shows the unification of a maybe type 
      <btypes:TYPE>
	<mbpair>
	  <type num="1"/>
	  <type num="1" dash="'"/>
	</mbpair>
      </btypes:TYPE> 
      with an unconstrained type  
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>. In this case, an immutable version of the
      constraint is extracted by the 
      <btypes:TYPE>
	<inner/>
      </btypes:TYPE> operator, and is unified with an immutable
      version of 
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>. Once compatibility is established, we unify
      the type 
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE> to equal 
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>.  U-Mb-Mb shows the unification of two maybe
      types. After establishing compatibility, 
      we unify the actual types  
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE> and 
      <btypes:TYPE>
	<type num="2"/> 
      </btypes:TYPE> so that they ultimately resolve to the same
      type. 
    </p>	
    <p>
      A constraint solver for solving copy compatibility constraints at 
      let-boundaries is 
      defined in Figure&nbsp;<xref ref="hm_solve"/>.          
      The judgment 
      <btypes:TYPE>
	<Sjudge name="solve">
	  <assume>
	    <aSubMap/>
	    <id/>
	    <aExpr/>
	  </assume>
	  <corUp>
	    <type num="1"/>
	    <type num="2"/>
	  </corUp>
	</Sjudge>
      </btypes:TYPE>
      should be read as: the (possibly) constrained type 
      <btypes:TYPE>
	<type num="1"/>
      </btypes:TYPE>
      for the identifier
      <btypes:TYPE>
	<id/>
      </btypes:TYPE>
      (possibly) used in the expression
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE>
      is transformed to the unconstrained type
      <btypes:TYPE>
	<type num="2"/>
      </btypes:TYPE>
      by solving all the copy compatibility constraints.
      The 
      <btypes:TYPE>
	<judgeOp name="s"/>
      </btypes:TYPE> rules solve the copy compatibility
      constraints within maybe types using their hints
      (Sol-Ct-Var), unless the maybe type has already unified
      with an unconstrained type (Sol-Ct-Const).
      The 	  
      <btypes:TYPE>
	<judgeOp name="solve"/>
      </btypes:TYPE> rule fixes the top-level mutability of maybe
      types based on whether the identifier 
      <btypes:TYPE>
	<id/>
      </btypes:TYPE> is actually the target of an assignment 
      within
      <btypes:TYPE>
	<aExpr/>
      </btypes:TYPE> 
      using the predicate <btypes:TYPE>
	<pred name="mut">	    
	  <id/>
	  <aExpr/>
	</pred>
      </btypes:TYPE>.
    </p>
    <p>
      <font size="small">
	<leadin>Definition 4 (Normalization of Constrained
	  Types)</leadin>
	<em> 
	  We write the normalization of a type 
	  <btypes:TYPE>	    
	    <type/>
	  </btypes:TYPE> as:
	  <btypes:TYPE>
	    <eq>              
	      <normalize>
		<type/>
	      </normalize>
	      <ctype>
		<canonical>
		  <type/>
		</canonical>
		<aCtset/>
	      </ctype>
	    </eq>
	  </btypes:TYPE>, wherein:
	  (1) All meta-constructors in 
	  <btypes:TYPE>
	    <canonical>
	      <type/>
	    </canonical>
	  </btypes:TYPE>      
	  are fully interpreted using the equivalences:
	  <btypes:TYPE>
	    <equiv>
	      <floor>
		<type/>
	      </floor>
	      <minz>
		<type/>
	      </minz>
	    </equiv>
	    <text content=" and "/>
	    <equiv>
	      <ceil>
		<type/>
	      </ceil>
	      <maxz>
		<type/>
	      </maxz>
	    </equiv>
	  </btypes:TYPE>,
	  (2) 
	  <btypes:TYPE>
	    <canonical>
	      <type/>
	    </canonical>
	  </btypes:TYPE>
	  contains no constrained types.
	  We write  
	  <btypes:TYPE>
	    <eq>
	      <normalize>
		<type/>
	      </normalize>
	      <canonical>
		<type/>
	      </canonical>
	    </eq>
	  </btypes:TYPE> if
	  <btypes:TYPE>
	    <eq>              
	      <normalize>
		<type/>
	      </normalize>
	      <ctype>
		<canonical>
		  <type/>
		</canonical>
		<aCtset/>
	      </ctype>
	    </eq>
	  </btypes:TYPE>, and 
	  <btypes:TYPE>
	    <aCtset/>
	  </btypes:TYPE> consists only of tautologies. 
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Definition 5 (Normalization of Constraint Sets)</leadin>
	<em>
	  A constraint set 
	  <btypes:TYPE>
	    <canonical>
	      <aCtset/>
	    </canonical>
	  </btypes:TYPE> is said to be the normalized form of 
	  <btypes:TYPE>
	    <aCtset/>
	  </btypes:TYPE>
	  (that is, 
	  <btypes:TYPE>
	    <eq>
	      <normalize>
		<aCtset/>
	      </normalize>
	      <canonical>
		<aCtset/>
	      </canonical>
	    </eq>
	  </btypes:TYPE>)
	  if it is written as a set of atomic constraints by using the
	  copy coercion rules defined in Figure&nbsp;<xref
	    ref="decl_all_rules"/>, and all transitively applicable
	  relationships explicitly added. Note that this conversion
	  is total. 
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Definition 6 (Normalization of Contexts)</leadin>
	<em>
	  The binding context 
	  <btypes:TYPE>
	    <canonical>
	      <gamma/>
	    </canonical>
	  </btypes:TYPE> is said to be the normalized form of 
	  <btypes:TYPE>
	    <gamma/>
	  </btypes:TYPE> 
	  (that is, 
	  <btypes:TYPE>
	    <eq>              
	      <normalize>
		<gamma/>
	      </normalize>
	      <canonical>
		<gamma/>
	      </canonical>
	    </eq>
	  </btypes:TYPE>) if          
	  <btypes:TYPE>
	    <Forall>
	      <in>
		<tqExpr>
		  <id/>
		  <type/>
		</tqExpr>
		<gamma/>
	      </in>
	    </Forall>
	    <text content=", "/>
	    <in>
	      <tqExpr>
		<id/>
		<canonical>
		  <type/>
		</canonical>
	      </tqExpr>
	      <canonical>
		<gamma/>
	      </canonical>
	    </in>
	    <text content=" and "/>
	    <eq>
	      <normalize>
		<type/>
	      </normalize>
	      <canonical>
		<type/>
	      </canonical>
	    </eq>
	  </btypes:TYPE>.
	  Similarly, 
	  <btypes:TYPE>
	    <eq>              
	      <normalize>
		<store/>
	      </normalize>
	      <canonical>
		<store/>
	      </canonical>
	    </eq>
	  </btypes:TYPE>) if          
	  <btypes:TYPE>
	    <Forall>
	      <in>
		<tqExpr>
		  <hLoc/>
		  <type/>
		</tqExpr>
		<store/>
	      </in>
	    </Forall>
	    <text content=", "/>
	    <in>
	      <tqExpr>
		<hLoc/>
		<canonical>
		  <type/>
		</canonical>
	      </tqExpr>
	      <canonical>
		<store/>
	      </canonical>
	    </in>
	    <text content=" and "/>
	    <eq>
	      <normalize>
		<type/>
	      </normalize>
	      <canonical>
		<type/>
	      </canonical>
	    </eq>
	    <text content="; and "/>
	    <Forall>
	      <in>
		<tqExpr>
		  <sLoc/>
		  <type/>
		</tqExpr>
		<store/>
	      </in>
	    </Forall>
	    <text content=", "/>
	    <in>
	      <tqExpr>
		<sLoc/>
		<canonical>
		  <type/>
		</canonical>
	      </tqExpr>
	      <canonical>
		<store/>
	      </canonical>
	    </in>
	    <text content=", and "/>
	    <eq>
	      <normalize>
		<type/>
	      </normalize>
	      <canonical>
		<type/>
	      </canonical>
	    </eq>
	  </btypes:TYPE>.
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Definition 7 (Consistent and Acyclic
	  Constraints)</leadin>
	<em>
	  We write
	  <btypes:TYPE>
	    <models name="cst">   
	      <assume/>
	      <aCtset/>
	    </models>                 
	  </btypes:TYPE> if 
	  <btypes:TYPE>
	    <aCtset/>
	  </btypes:TYPE> does not (transitively) include any
	  contradictions like 
	  <btypes:TYPE>
	    <Tsub>
	      <bool/>
	      <unit/>
	    </Tsub>
	  </btypes:TYPE>. 
	  We write
	  <btypes:TYPE>
	    <models name="cst">   
	      <assume/>
	      <type/>
	    </models>  
	    <text content=" if "/>
	    <eq>
	      <normalize>
		<type/>
	      </normalize>
	      <ctype>
		<canonical>
		  <type/>
		</canonical>
		<aCtset/>
	      </ctype>
	    </eq>
	    <text content=" and "/>
	    <models name="cst">   
	      <assume/>
	      <aCtset/>
	    </models>  	    
	  </btypes:TYPE>.
	  The 
	  <btypes:TYPE>
	    <assume/>
	    <models name="acl"/>   
	  </btypes:TYPE>
	  judgment asserts that a set of constraints
	  are acyclic. We write 
	  <btypes:TYPE>
	    <models name="ca">   
	      <assume/>
	      <aCtset/>
	    </models>  
	    <text content=" iff "/>
	    <models name="cst">   
	      <assume/>
	      <aCtset/>
	    </models>  	    
	    <text content=" and "/>
	    <models name="acl">   
	      <assume/>
	      <aCtset/>
	    </models>  	    	    
	  </btypes:TYPE>.
	</em>
      </font>
    </p>
    <p>
      <font size="small">
      <leadin>Lemma 3 (Correctness of Unification)</leadin>
	<em>
	  <btypes:TYPE>
	    <text content="If "/>
	    <eq>
	      <normalize>
		<type num="1"/>
	      </normalize>
	      <ctype>
		<canonical>
		  <type num="1"/>
		</canonical>
		<aCtset num="1"/>
	      </ctype>
	    </eq>            
	    <text content=", "/>
	    <eq>
	      <normalize>
		<type num="2"/>
	      </normalize>
	      <ctype>
		<canonical>
		  <type num="2"/>
		</canonical>		
		<aCtset num="2"/>
	      </ctype>
	    </eq>
	    <text content=", "/>
	    <models name="ca">   
	      <assume/>
	      <aCtset num="1"/>
	    </models>                 
	    <text content=", "/>
	    <models name="ca">   
	      <assume/>
	      <aCtset num="2"/>
	    </models>                 
	    <text content=", "/>
	    <UNIFY>
	      <type num="1"/>
	      <type num="2"/>              
	      <aSubMap/>
	    </UNIFY>
	    <text content=", and "/>
	    <eq>
	      <aCtset/>
	      <canonical>
		<unin>
		  <set>
		    <eq>
		      <canonical>
			<type num="1"/>
		      </canonical>
		      <canonical>
			<type num="2"/>
		      </canonical>
		    </eq>
		  </set> 
		  <aCtset num="1"/>
		  <aCtset num="2"/>
		</unin>
	      </canonical>
	    </eq>	      
	    <text content=", then "/>
	    <models name="ca">   
	      <assume/>
	      <aCtset/>
	    </models>                 
	    <text content="."/>
	  </btypes:TYPE>
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Lemma 4 (Correctness of the Constraint Solver)</leadin>
	<em>
	  If
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<aSubMap/>
	      </assume>
	      <corUp>
		<type/>
		<type dash="'"/>
	      </corUp>
	    </Sjudge>
	    <text content=" then "/>
	    <eq>
	      <normalize>
		<Subst>
		  <aSubMap/>
		  <type/>
		</Subst>
	      </normalize>
	      <canonical>
		<type dash="'"/>
	      </canonical>
	    </eq>
	  </btypes:TYPE>.
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Lemma 5 (Totality of the Solver)</leadin>
	<em>
	  If          
	  <btypes:TYPE>
	    <models name="cst">
	      <assume/>
	      <type/>
	    </models>
	    <text content=", then "/>
	    <Exists>
	      <aSubMap/>
	    </Exists>
	    <text content=" such that "/>            
	    <Sjudge name="s">
	      <assume>
		<aSubMap/>
	      </assume>
	      <corUp>
		<type/>
		<type dash="'"/>
	      </corUp>	     
	    </Sjudge>
	  </btypes:TYPE>.
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Lemma 6 (Decidability of Unification and Solver)</leadin>
	<em>
	  If 
	  <btypes:TYPE>
	    <models name="acl">
	      <assume/>
	      <type/>
	    </models>
	    <text content=" and "/>
	    <models name="acl">
	      <assume/>
	      <type dash="'"/>
	    </models>
	  </btypes:TYPE>, then,        
	  a normalizing derivation of 
	  <btypes:TYPE>
	    <UNIFY>
	      <type/>
	      <type dash="'"/>
	      <aSubMap/>
	    </UNIFY>
	  </btypes:TYPE>
	  where no two uses of U-Commut occur consecutively, and, 
	  the derivation of
	  <btypes:TYPE>
	    <Sjudge name="s">
	      <assume>
		<aSubMap/>
	      </assume>
	      <corUp>
		<type/>
		<type dash="''"/>
	      </corUp>
	    </Sjudge>
	    <text content=" are decidable."/>
	  </btypes:TYPE>
	</em>
      </font>
    </p>
    <p>
      <font size="small">
	<leadin>Theorem 2 (Soundness of Inference)</leadin>
	<em>
	  <btypes:TYPE>
	    <text content="If "/>
	    <TIjudge>
	      <assume>
		<gamma/>
		<store/>
	      </assume>
	      <conclude>
		<tqExpr>
		  <aExpr/>
		  <type/>
		</tqExpr>
	      </conclude>
	      <propagate>
		<aSubMap num="1"/>
	      </propagate>
	    </TIjudge>
	    <text content=" and "/>
	    <Sjudge name="s">
	      <assume>
		<aSubMap num="2"/>
	      </assume>
	      <corUp>
		<type/>
		<type dash="'"/>
	      </corUp>
	    </Sjudge>
	    <text content=" then "/>          
	    <exists>
	      <aSubMap dash="'"/>
	    </exists>
	    <text content=" such that "/>
	    <eq>
	      <aSubMap/>
	      <compose>		
		<aSubMap dash="'"/>
		<aSubMap num="1"/>
		<aSubMap num="2"/>
	      </compose>
	    </eq>
	    <text content=" and "/>
	    <Sjudge>
	      <assume>
		<canonical>
		  <Subst>
		    <aSubMap/>
		    <gamma/>
		  </Subst>
		</canonical>	
		<canonical>
		  <Subst>
		    <aSubMap/>
		    <store/>
		  </Subst>
		</canonical>
	      </assume>
	      <tqExpr>
		<aExpr/>
		<canonical>
		  <type dash="'"/>
		</canonical>
	      </tqExpr>
	    </Sjudge>	    
	  </btypes:TYPE>.
	</em>
	<br/>
	<em>Proof:</em>
	By induction on the derivation of 
	<btypes:TYPE>
	  <TIjudge>
	    <assume>
	      <gamma/>
	      <store/>
	    </assume>
	    <conclude>
	      <tqExpr>
		<aExpr/>
		<type/>
	      </tqExpr>
	    </conclude>
	    <propagate>
	      <aSubMap num="1"/>
	    </propagate>
	  </TIjudge>
	</btypes:TYPE>
  </font>
  </p> -->
  </sect1>
  <sect1 id="related">
    <title>Related Work</title>
    <p>
      Grossman&nbsp;<cite ref="Grossman2006qtypes"/> provides a theory
      of using quantified types with imperative C style mutation for
      Cyclone. However, his formalization requires explicit annotation
      for all polymorphic definitions and instantiations. In contrast,
      we believe that the best way to integrate polymorphism into the
      systems programming paradigm is by automatic inference. A
      further contribution of our work (in comparison to&nbsp;<cite
      ref="Grossman2006qtypes"/>) is that we 
      give a formal specification and proof of correctness of the
      inference algorithm, not just the type system.
    </p>
    <p>
      C's <progident>const</progident> notion of immutability-by-alias
      offers localized checking of immutability properties, and
      encourages good programming practice by serving as documentation
      of programmers intentions.  Other systems have proposed
      immutability-by-name&nbsp;<cite ref="DeLineMSRVault"/>,
      referential immutability&nbsp;<cites>
	<cite ref="shapiro1999EROS"/>
	<cite ref="tschantz2005javari"/>
      </cites>
      (transitive immutability-by-reference),
      <foreignphrase>etc.</foreignphrase> These techniques are
      orthogonal and complementary to the immutability-by-location
      property in <btypes:TYPE><language/></btypes:TYPE>. For
      example, we could have types like
      <btypes:TYPE>
	<paren>
	  <text content="const "/>
	  <mutable>
	    <type/>
	  </mutable>
	</paren>
      </btypes:TYPE> that can express
      both global and local usage properties of a location.
    </p>
    <p>
      A monadic model&nbsp;<cite ref="peytonjones1993monads"/>
      of mutability is used in pure functional languages like
      Haskell&nbsp;<cite ref="peytonjones2003haskellrevisedreport"/>.
      In this model, the type system distinguishes side-effecting
      computations from pure ones (and not just mutable locations
      from immutable ones). Even though this model is beneficial for
      integration with verification systems, it is considerably
      different from the normal programming idioms used by systems
      programmers. For example,  Hughes argues that there is no
      satisfactory way of creating and using global mutable variables
      using monads&nbsp;<cite ref="Hughes2004HaskellGlobals"/>. 
      There have been proposals for adding unboxed representation
      control to Haskell&nbsp;<cites>
	<cite ref="peytonjones1991unboxed"/>
	<cite ref="Diatchki2005Representation"/>
      </cites>. However, these systems are pure and therefore and do
      not consider the effects of mutability.
    </p>
    <p>
      Cqual&nbsp;<cite ref="foster2006Cqual"/> provides a framework
      of type qualifiers, which can be used to infer maximal
      <progident>const</progident> qualifications for C
      programs. However, CQual does not deal with polymorphism
      of types. In a monomorphic language, we can infer types and
      qualifiers independently. Adding polymorphism to CQual
      would introduce substantial challenges, particularly if
      polymorphism should be automatically inferred. The inference of
      types and qualifiers (mutability) becomes co-dependent: we need
      base types to infer qualifiers; but, we also need the qualifiers
      to infer base types due to the value
      restriction. 
      <btypes:TYPE>
	<language/>
      </btypes:TYPE> supports
      a polymorphic language and performs simultaneous
      inference of base types and mutability.
    </p>
  </sect1>
  <sect1 id="conclusion">
    <title>Conclusions</title>
    <p>
      In this paper, we have proposed a type system that integrates
      all of unboxed representation, well-founded first-class
      mutability, and polymorphism. The mutability model is expressive
      enough to permit mutation of unboxed/stack locations, and at the
      same time guarantees that types are definitive about the
      mutability of every location across all aliases. 
      This type system meets the requirements of systems programming
      languages.
    </p>
    <p>
      First class mutability introduces challenges for type inference
      at copy boundaries. We have proposed a novel algorithm that
      infers principal types using a system of constrained types. To
      our knowledge, this is the first sound and complete algorithm
      that infers both mutability and polymorphism in a systems
      programming language with copy compatibility.  
    </p>
    <p>    
      The type inference algorithm is implemented as part of the
      BitC&nbsp;<cite ref="shapBitcSpec2006"/> language compiler.
      <font color="purple">
	The core of the compiler involves 22,433 lines of C++ code, of
	which implementation of the type system accounts for about
	7,816 lines.
      </font> The source code can be obtained from
      <link href="http://www.ecma-international.org/publications/standards/Ecma-334.htm">
	<progident>http://bitc-lang.org</progident>.  
      </link>
    </p>
  </sect1>
  <!--   <sect1 id="acknowledgments" numbered="no"> -->
  <!--     <title>Acknowledgments</title> -->
  <!--     <p> -->
  <!--       <em>Undisclosed for anonymization.</em> -->
  <!--       Mark Jones was kind enough to educate us on type -->
  <!--       classes, which provided an essential basis for integrating these -->
  <!--       ideas. Foster, Iavor, Pari, bitc-dev... -->
  <!--     </p> -->
  <!--   </sect1> -->
  <bibliography>
      <font size="scriptsize">
    <bibentry label="Alexander98"> 
      <!-- <key>Alexander98</key> -->
      D. S. Alexander, W. A. Arbaugh, M. W. Hicks, P. Kakkar,
      A. D. Keromytis, J. T. Moore, C. A. Gunder, S. M. Nettles,
      and J. M. Smith. 
      ``The SwitchWare active network architecture''
      <doctitle>
	IEEE Network
      </doctitle>
      May/June 1998.
    </bibentry>
    <bibentry label="Biagioni2001FoxNet"> 
      <!-- <key>Biagioni01</key> -->
      E. Biagioni, R. Harper, and P. Lee
      ``A network protocol stack in Standard ML''
      <doctitle>
        Higher Order and Symbolic Computation, Vol.14, No.4
      </doctitle>,
      2001.
    </bibentry>
    <bibentry label="DeLineMSRVault">
      <!-- <key>DeLine01</key> -->
      R. Deline and M. F&auml;hndrich,
      ``VAULT: a programming language for reliable systems''
      <link href="http://research.microsoft.com/vault">
        <progident>http://research.microsoft.com/vault</progident>
      </link>, 2001
    </bibentry>
    <bibentry label="Derby1999Foxnet">
      <!-- <key>Derby99</key> -->
      H. Derby,
      ``The performance of FoxNet 2.0''
      <doctitle>
	Technical Report CMU-CS-99-137
      </doctitle>
      School of Computer Science, Carnegie Mellon University, 
      June 1999. 
    </bibentry> 
    <bibentry label="csharpSpec"> 
      <!-- <key>ECMA06</key> -->
      ECMA International
      ``Standard ECMA-334 C# Language Specification''
      <link href="http://www.ecma-international.org/publications/standards/Ecma-334.htm">
        <progident>http://www.ecma-international.org/publications/standards/Ecma-334.htm</progident>
      </link><!--,2006.-->
    </bibentry>
    <bibentry label="foster2006Cqual">
      <!-- <key>Foster06</key> -->
      J. S. Foster, R. Johnson, J. Kodumal, and A. Aiken
      ``Flow-Insensitive Type Qualifiers''
      <doctitle>
	Trans. on Programming Languages and Systems. 
      </doctitle>
      28(6):1035-1087, Nov. 2006.  
    </bibentry>
    <bibentry label="Grossman2006qtypes">
      <!-- <key>Grossman06</key> -->
      D. Grossman, ``Quantified Types in an Imperative Language''
      <doctitle>ACM Transactions on Programming Languages and Systems
      </doctitle>, 
      2006.
    </bibentry>
    <bibentry label="Hughes2004HaskellGlobals">
      <!-- <key>Hughes04</key> -->
      J. Hughes 	 
      ``Global variables in Haskell''
      <doctitle>
	Journal of Functional Programming archive
      </doctitle>
      Volume 14,  Issue 5, Sept. 2004.
    </bibentry>
    <bibentry label="Diatchki2005Representation">
      <!-- <key>Diatchki05</key> -->
      I. S. Diatchki, M. P. Jones, and R. Leslie.
      ``High- level Views on Low-level Representations.''
      <doctitle>Proc. ACM Int. Conference on Functional
        Programming</doctitle> pp. 168&ndash;179, 
      2005.
    </bibentry>
    <bibentry label="ISO1995Ada">
      <!-- <key>ISO95</key> -->
      International Std. Organization
      <doctitle>ISO/IEC 8652:1995 (Information
      Technology &mdash; Prog.
      Languages &mdash; Ada)</doctitle>, 1995.
    </bibentry>
    <bibentry label="ISO1998C++">
      <!-- <key>ISO98</key> -->
      International Std. Organization
      <doctitle>ISO/IEC FDIS 14882:1998(E) (Prog.
	Lang. - C++)</doctitle>, 1998.
    </bibentry>
    <bibentry label="ISO1999ANSI-C">
      <!-- <key>ISO99</key> -->
      International Std. Organization
      <doctitle>ISO/IEC 9899:1999 (Prog.
	Languages - C)</doctitle>, 1999.
    </bibentry>
    <bibentry label="Jim2002Cyclone">
      <!-- <key>Jim02</key> -->
      T. Jim, G. Morrisett, D. Grossman, M. Hicks, J. Cheney, and
      Y. Wang  
      ``Cyclone: A safe dialect of C.'' 
      <doctitle>
        Proc. of USENIX Annual Technical Conference 
      </doctitle>
      pp 275288, 2002. 
    </bibentry>
    <bibentry label="jones1995qualtypes">
      <!-- <key>Jones95</key> -->
      M. P. Jones
      ``Qualified types: theory and practice.''
      <doctitle>
	Cambridge Distinguished Dissertations In Computer Science
      </doctitle>
      ISBN:0-521-47253-9, 1995
    </bibentry>
    <bibentry label="peytonjones1991unboxed">
      <!-- <key>Jones91</key> -->
      S. L. Peyton Jones and J. Launchbury
      ``Unboxed values as first class citizens in a non-strict
      functional language.''
      <doctitle>
	Functional Programming Languages and Computer Architecture
      </doctitle>,
      1991
    </bibentry>
    <bibentry label="peytonjones1993monads">
      <!-- <key>Jones93</key> -->
      S. L. Peyton Jones and P. Wadler
      ``Imperative functional programming.''
      <doctitle>
	Proc. ACM SIGPLAN Principles of Programming Languages.
      </doctitle>,
      1993
    </bibentry>  
    <bibentry label="peytonjones2003haskellrevisedreport">
      <!-- <key>Jones03</key> -->
      S. L. Peyton Jones (ed.). <doctitle>Haskell 98 Language and
	Libraries: The Revised report</doctitle>. Cambridge University
	Press, 2003.
    </bibentry>
    <bibentry label="LeroyOcaml">
      <!-- <key>Leroy05</key> -->
      Xavier Leroy,  
      ``The Objective Caml System Release 3.09, Documentation and
      User's Manual.''
      <link
        href="http://caml.inria.fr/pub/docs/manual-ocaml/index.html">
        <progident>http://caml.inria.fr/pub/docs/ manual-ocaml/index.html</progident>
      </link> 
    </bibentry>
    <bibentry label="Milner1978W">
      <!-- <key>Milner78</key> -->
      R. Milner 
      ``A theory of type polymorphism in programming.''
      <doctitle>
        Journal of Computer and System Sciences
      </doctitle>
      pp 348-375, 1978.
    </bibentry>
    <bibentry label="milner97definition">
      <!-- <key>Milner97</key> -->
      R. Milner, M. Tofte, R. Harper, and D.MacQueen. 
      <doctitle>The Definition of Standard ML - Revised</doctitle>
      The MIT Press, May 1997.
    </bibentry>
<!--     <bibentry label="necula2002CCured"> -->
<!--       <key>Necula02</key> -->
<!--       G. Necula, S. Mcpeak, and W. Weimer  -->
<!--       ``CCured: Type-safe retrofitting of legacy code.'' -->
<!--       <doctitle> -->
<!--         Proc. of Symposium on Principles of Programming Languages -->
<!--       </doctitle>  -->
<!--       pp 128139, 2002. -->
<!--     </bibentry> -->
<!--     <bibentry label="pierce2002TypesBook"> -->
<!--       <key>Pierce02</key> -->
<!--       B. C. Pierce -->
<!--       ``Types and Programming Languages'' -->
<!--       <doctitle> -->
<!-- 	The MIT Press, Massachusetts Institute of Technology -->
<!--       </doctitle> -->
<!--       ISBN 0-262-16209-1, 2002.       -->
<!--     </bibentry> -->
    <bibentry label="javaSpec">
      <!-- <key>Gosling05</key> -->
      J. Gosling, B. Joy, G. Steele, and G. Bracha
      ``The Java Language Specification,'' Third Edition
      <link href="http://java.sun.com/docs/books/jls">
        <progident>http://java.sun.com/docs/books/jls</progident>
      </link>
    </bibentry>
    <bibentry label="pythonSpec"> 
      <!-- <key>Rossum06</key> -->
      G. van Rossum, ``Python Reference Manual''
      F. L. Drake, Jr. (ed.)
      <link href="http://docs.python.org/ref/ref.html">
        <progident>http://docs.python.org/ref/ref.html</progident>
      </link>, 2006.
    </bibentry>
    <bibentry label="shapiro1999EROS">
      <!-- <key>Shapiro99</key> -->
      J. S. Shapiro, J. M. Smith, and D. J. Farber. 
      ``EROS: a fast capability system''
      <doctitle>
	ACM Symposium on Operating Systems Principles
      </doctitle>,
      Dec. 1999.
    </bibentry>
    <bibentry label="shapBitcSpec2006">
      <!-- <key>U1</key> -->
      J. S. Shapiro, S. Sridhar, M. S. Doerrie, ``BitC Language
      Specification''
      <link
      href="http://bitc-lang.org/docs/bitc/spec.html">
      <progident>http://www.bitc-lang.org/docs/bitc/spec.html</progident>
      </link>
    </bibentry>
    <bibentry label="Smith1998polymorphicC">
      <!-- <key>Smith98</key> -->
      G. Smith and D. Volpano. 
      ``A sound polymorphic type system for a dialect of C.''
      <progident>
	Science of Computer Programming
      </progident>
      <b>32</b>(2--3):49--72, 1998. 
    </bibentry>
    <bibentry label="sridhar2006plos">
      <!--  <key>Sridhar06</key> -->
      S. Sridhar and J. S. Shapiro. ``Type Inference for Unboxed Types
      and First Class Mutability'' 
      <doctitle>Proc. 3rd Workshop on Prog. Languages and
	Operating Systems</doctitle>, 2006. 
    </bibentry>
    <bibentry label="sridhar2007formal">
      <!-- <key>Sridhar07</key> -->
      S. Sridhar, J. S. Shapiro and S. F. Smith
      ``Proof of Soundness of BitC Type System and Inference Algorithm''
      <link
	href="http://bitc-lang.org/docs/bitc/c-formal.pdf">
	<progident>http://www.bitc-lang.org/docs/bitc/c-formal.pdf</progident>
      </link><!-- , 2007 -->.
    </bibentry>
    <bibentry label="Tarditi1996TIL"> 
      <!-- <key>Tarditi96</key> -->
      D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and
      P. Lee. 
      ``TIL: A type-directed optimizing compiler
      for ML''
      <doctitle>
        Proc. ACM SIGPLAN PLDI
      </doctitle>, 1996. 
    </bibentry>
    <bibentry label="tschantz2005javari">
      <!-- <key>Tschantz05</key> -->
      M. S. Tschantz and M. D. Ernst,     
      ``Javari: Adding reference immutability to Java''
      <doctitle>
	Object-Oriented Programming Systems, Languages, and
	Applications
      </doctitle>,
      Oct 2005.
    </bibentry>
    <bibentry label="wrightValRes1995">
      <!-- <key>Wright95</key> -->
      A. Wright, ``Simple Imperative Polymorphism'' 
      <doctitle> Lisp and Symbolic Comp.</doctitle>
      8(4):343-355, 1995.
    </bibentry>
    </font>
  </bibliography>
</article>

<!--       <btypes:TYPE> -->
<!-- 	<grammar notitle="yes"> -->
<!-- 	  <bnf2> -->
<!-- 	    <bnf desc="Identifiers"> -->
<!-- 	      <id/> -->
<!-- 	      <alternatives etc="yes"> -->
<!-- 		<id name="y"/> -->
<!-- 		<id name="z"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	    <bnf desc="Stack Locations"> -->
<!-- 	      <sLoc/> -->
<!-- 	      <alternatives etc="yes"> -->
<!-- 		<sLoc num="1"/> -->
<!-- 		<sLoc num="2"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	    <bnf desc="Heap Locations"> -->
<!-- 	      <hLoc/> -->
<!-- 	      <alternatives etc="yes"> -->
<!-- 		<hLoc num="1"/> -->
<!-- 		<hLoc num="2"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	  <bnf2>	     -->
<!-- 	    <bnf desc="lvalues"> -->
<!-- 	      <lVal/> -->
<!-- 	      <alternatives> -->
<!-- 		<sLoc/> -->
<!-- 		<deref> -->
<!-- 		  <hLoc/> -->
<!-- 		</deref> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	    <bnf desc="Values"> -->
<!-- 	      <aVal/> -->
<!-- 	      <alternatives> -->
<!-- 		<Unit/> -->
<!-- 		<true/> -->
<!-- 		<false/> -->
<!-- 		<hLoc/> -->
<!-- 		<lambda> -->
<!-- 		  <id/> -->
<!-- 		  <aExpr/> -->
<!-- 		</lambda> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	  <bnf2 colspan="3"> -->
<!-- 	    <bnf desc="Expressions"> -->
<!-- 	      <aExpr/> -->
<!-- 	      <alternatives> -->
<!-- 		<aVal/> -->
<!-- 		<sLoc/> -->
<!-- 		<apply> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</apply> -->
<!-- 		<tqExpr> -->
<!-- 		  <aExpr/> -->
<!-- 		  <type/> -->
<!-- 		</tqExpr> -->
<!-- 		<assign> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</assign>  -->
<!-- 		<dup> -->
<!-- 		  <aExpr/> -->
<!-- 		</dup> -->
<!-- 		<deref> -->
<!-- 		  <aExpr/> -->
<!-- 		</deref> -->
<!-- 		<if> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</if> -->
<!-- 		<let kind="k"> -->
<!-- 		  <tqExpr optional="yes"> -->
<!-- 		    <id/> -->
<!-- 		    <type/> -->
<!-- 		  </tqExpr> -->
<!-- 		  <aExpr/> -->
<!-- 		  <aExpr/> -->
<!-- 		</let> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	  <bnf2 colspan="3"> -->
<!-- 	    <bnf desc="Let-kinds"> -->
<!-- 	      <symbol name="kappa"/> -->
<!-- 	      <alternatives> -->
<!-- 		<text content="-"/> -->
<!-- 		<symbol name="alpha"/> -->
<!-- 		<symbol name="psi"/> -->
<!-- 		<symbol name="forall"/> -->
<!-- 	      </alternatives> -->
<!-- 	    </bnf> -->
<!-- 	  </bnf2> -->
<!-- 	</grammar> -->
<!--       </btypes:TYPE> -->


<!-- Local Variables: -->
<!-- indent-tabs-mode:nil -->
<!-- End: -->

<!--  LocalWords:  sysinfer twocolumn ptsz documentclass sigplanconf firstname
 -->
<!--  LocalWords:  authorgroup orgname mdash Coyotos shapiro coyotos ACL acl se
 -->
<!--  LocalWords:  kaufmann milner peytonjones haskellrevisedreport Kernighan
 -->
<!--  LocalWords:  CCured necula Condit cycloneManual Grossman qtypes Volpano
 -->
<!--  LocalWords:  SmithVolpanoPTVR const cpi cong ncong foreignphrase hoc mb
 -->
<!--  LocalWords:  sridharmutinfer boolPair sem dup bnf desc sLoc hLoc aVal ARG
 -->
<!--  LocalWords:  aExpr lvalues lVal tqExpr bnfc opsem opState eval levalOp et
 -->
<!--  LocalWords:  evalOp floatingtable fullwidth Hrules opRule RVAL opPre dom
 -->
<!--  LocalWords:  mapsto opConc leval notin subst Diatchki defrepr monad Cqual
 -->
<!--  LocalWords:  SysObjC balogh sysobjc IEC Aacute aacute Zolt ouml rnyei ACM
 -->
<!--  LocalWords:  Proc ECOOP Kluwer auml hndrich SIGPLAN PLDI ndash Sriram MLC
 -->
<!--  LocalWords:  Rajamani SIGACT McCloskey Zhou HotOS USENIX dependentMut th
 -->
<!--  LocalWords:  IEEE Verlag Mads Tofte MacQueen Iavor hallgren Tolmach ICFP
 -->
<!--  LocalWords:  Sep shap fastcapsystem Farber Kiawah Mcpeak Weimer Harren Ph
 -->
<!--  LocalWords:  Morrisett PolymorphismTypeAnalysis Symp Shao Zhong DeLine im
 -->
<!--  LocalWords:  Deline Fahndrich LeroyOcaml Caml fahndrich Hawblitzel Hodson
 -->
<!--  LocalWords:  Lauris EUROSYS Leuven aiken MSR sridhar PLOS Hindley uint gg
 -->
<!--  LocalWords:  Worshop Northup online bitfield Arith dereferencing mVal dyn
 -->
<!--  LocalWords:  bPtr polyinstantiated updatable rvalues lval TypEvalPred aTS
 -->
<!--  LocalWords:  pred Csubst Pari ocaml anonymization ML's twelf Nipkow inria
 -->
<!--  LocalWords:  coq ppabs dereferences HaskellonProcessor mtverify jones TCL
 -->
<!--  LocalWords:  qualtypes texttt mtd lang xmli horz maxzOp minzOp eq maxz na
 -->
<!--  LocalWords:  minz covariant arg ret ceil Tsub locsem decl specsharp CADE
 -->
<!--  LocalWords:  Monads Carsten LNAI Paulson Wenzel HOL LNCS Millstein eiffel
 -->
<!--  LocalWords:  DeLineVault Schoeller Bernd Zhiming Liu FACS Rustan Leino ve
 -->
<!--  LocalWords:  Schulte CASSIS specsharpreleasenotes Smans Piessens tschantz
 -->
<!--  LocalWords:  javari leadin isZthTrue Pfenning mVec mLst backend ShaoRep
 -->
<!--  LocalWords:  leroyUBobj harperPoly RTTI polyinst letvar letarr defpure ol
 -->
<!--  LocalWords:  GHC VFiasco hohmuth BitC's releasenotes uuml ghcManual Tews
 -->
<!--  LocalWords:  plos iuml analyses TDjudge judgeOp Sjudge unin supeq TIjudge
 -->
<!--  LocalWords:  aSubMap corUp corUpOp solvability rmann unifications revalOp
 -->
<!--  LocalWords:  reval epsiv TypesBook leroy polymorphicC Launchbury monads
 -->
<!--  LocalWords:  stateinHaskell Wadler ceqOp neq FirstName LastName liveness
 -->
<!--  LocalWords:  Tarditi javaSpec csharpSpec DeLineMSRVault schemeSpec thinsp
 -->
<!--  LocalWords:  pythonSpec runtime marshall unmarshall FoxNet TCP IP SubMap
 -->
<!--  LocalWords:  Biagioni Volpano's unkinded mbpair OTH Edoardo Larus Abadi
 -->
<!--  LocalWords:  amd Barha Steensgaard Wobber Zill Gilad Bracha ECMA Rossum
 -->
<!--  LocalWords:  Cheng tyRule tyPre tyConc isEntity REFL CQual xml DOCTYPE fn
 -->
<!--  LocalWords:  OSDoc xmlns btypes docinfo pubdate dev bitc BitC incolumn al
 -->
<!--  LocalWords:  unboxed nbsp shapBitcSpec mut compat SparkAdaBook SML OCaml
 -->
<!--  LocalWords:  progident Foxnet literallayout forall IntLit defstruct fst
 -->
<!--  LocalWords:  snd defunion cdr inlined Diatchi Sys Usr typ bool stateful
 -->
<!--  LocalWords:  xyz dereferenced deref constness ndx ident ul li lvalue tvar
 -->
<!--  LocalWords:  behaviour ceq sz accessor wrightValRes monomorphic tradeoffs
 -->
<!--  LocalWords:  ness vec lst abc deftypeclass definstance num href LHS RHS
 -->
<!--  LocalWords:  aCtset br subtyping iff contravariant tvars Xform Commut CMU
 -->
<!--  LocalWords:  polyinstantiation microkernel datatypes bibentry doctitle cp
 -->
<!--  LocalWords:  SparkAda Doerrie Swaroop Multithreaded Multithreading useF
 -->
<!--  LocalWords:  Kodumal fPtr polymorphically asplas llncs notitle copyList
 -->
<!--  LocalWords:  optionalElse dereference mutLst nospace listCopy bp textit
 -->
<!--  LocalWords:  allTrue rvalue reified HaskellGlobals SRL colspan benefacts
 -->
	
<!--  LocalWords:  ctype fnxn paren initsep colsep globals tbody valign td Loc
 -->
<!--  LocalWords:  Exprs TypeScheme Env Rval Oth cst Prog mutinfer de facto SHA
 -->
<!--  LocalWords:  scriptsize FDIS Keromytis Gunder SwitchWare inequations
 -->
<!--  LocalWords:  Arbaugh Kakkar
 -->
